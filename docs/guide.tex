\documentclass[11pt]{article}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage[margin=0.9in]{geometry}
\usepackage{color, colortbl}

\definecolor{hgray}{gray}{0.9}
 
\pagestyle{fancy}
\def\sectionautorefname{Section}


\title{nomodo - Manage your system by yourself}
\author{Autori (in ordine alfabetico): \and Giuseppe Glorioso \and Lucia Polizzi}

\begin{document}
\lstset{
	language=Python,
	frame=single,
	breaklines=true,
	breakatwhitespace=false,
	backgroundcolor=\color{hgray}
}
\maketitle
\pagenumbering{gobble}

\newpage
\tableofcontents
\pagenumbering{arabic}

\newpage

\section{Introduzione}

\subsection{Introduzione al progetto}
Il progetto nomodo nasce dalla necessit\'a di un applicativo di gestione dei sistemi Ubuntu che sia più immediato ed accessibile
rispetto al classico terminale, e quindi utilizzabile anche dagli utenti che per un motivo o per un altro
non possono o non vogliono avere a che fare con il terminale.
Nomodo si prende in carico di eseguire tutte le chiamate al terminale o meno per eseguire operazioni atte alla gestione del sistema
presentando all'utente una interfaccia web chiara e comprensibile.
Per operazioni in questo caso si intendono l'aggiornamento, la manutenzione e il miglioramento del sistema come ad esempio
l'installazione dei pacchetti, la ricerca e la modifica dei file, così come operazioni di più alto livello come
la gestione basilare del web server Apache.

\subsection{Informazioni tecniche}
\paragraph{Python + Flask}
L'applicativo scritto in python è basato sul framework Flask, utilizzato tra l'altro come webserver per l'accesso al pannello.
Durante la fase di sviluppo si è utilizzato nginx come reverse proxy in modo da poter raggiungere il pannello web sulla porta 80 e non sulla 5000.
È stata presa poi in seguito la decisione di lasciare che l'applicativo girasse sulla porta 5000 in quannto meno comune e quindi
meno alla mercé degli hacker.
\\~\\
L'applicazione è stata quindi divisa in modo netto nelle due componenti fondamentali, il \nameref{frontend} e il \nameref{backend}
che anche andremo quindi ad analizzare qui brevemente e più approfinditamente nei capitoli successivi:
\begin{itemize}
	\label{backendintro}
	\item{
			Il \textbf{backend} consiste in una serie di funzioni raccolte in una serie di file a mò di libreria,
			risiedenti nella cartella \texttt{systemcalls} (come ad es. \texttt{system.py} o \texttt{user.py}), utilizzati
			sia per la raccolta di dati sia per eseguire azioni sul sistema che non necessitano di output in uscita}
	\label{frontendintro}
	\item{
			Il \textbf{frontend} rappresenta la parte grafica dell'applicativo web, e utilizza le funzioni
			del backend per la ricerca di informazioni e per la modifica alle componenti del sistema
			inclusa la modifica dei file quali i file di configurazioni}
\end{itemize}

\paragraph{MongoDB}
Ogni operazione sensibile effettuata tramite l'applicazione comporta la memorizzazione delle modifiche che comporta la stessa
in documento di mongodb, cos\'i da poter risalire alla storia delle operazioni effettuate e tentare un revert delle modifiche
in caso ad esempio il sistema perda di stabilità o le modifiche non portino al risultato sperato.
Tali operazioni possono riguardare ad esempio la modifica di un file, o la rimozione di un pacchetto dal sistema.
Ogni log in mongodb presenta inoltre un flag \textbf{status} che indica se l'operazione eseguita sia andata a buon fine
o meno, in modo da rendere più chiara la navigazione tra i log e dare la possibiltà all'utente di filtrarli in base a questo campo.
\footnote{\label{loglimit1}
Le uniche operazioni memorizzate nel database sono quelle relative all'utilizzo dell'applicativo;
una modifica effettuata direttamente sul sistema ad esempio tramite il terminale va incontro alle regole del sistema Ubuntu
e ogni modifica potrebbe essere irreversibile. In questi casi fare riferimento ai log del sistema che è possibile trovare
al percorso \texttt{/var/log/} o sul pannello web alla sezione \texttt{Log}. }

\section{Backend}\label{backend}
Come anticipato in sezione \ref{backendintro} il backend è composto da una serie di funzioni raggruppate per categoria
che fanno utilizzo di varie librerie python per compiere operazioni che possono o meno alterare lo stato del sistema.
Allo stato attuale le categorie che compongono il backend sono le seguenti:
\begin{itemize}
	\item{Utenti}
	\item{Network}
	\item{Cron}
	\item{Sistema}
	\item{Apache}
	\item{Database}
	\item{File}
	\item{Logs}
\end{itemize}

\paragraph{Interfaccia al frontend}\label{frontendinterface}
Ogni funzione chimata restituisce sempre un dizionario contenente almeno n codice di ritorno e il logid del documento inserito
in mongo con un mongo \texttt{\_id} se applicabile\footnote{\label{mongologwhen}
Cioè in caso l'operazione sia una operazione sensibile e richieda quindi un inserimento in mongo per tenere traccia della stessa}
oppure un logid \texttt{None} se non è stato creato alcun log.
Distinguiamo quindi 2 casi in base al valore della variabile \texttt{returncode}:
\begin{itemize}
	\item{Se $returncode = 0$ l'operazione è andata a buon fine e il dizionario conterrà una terza variabile \texttt{data}
		che conterrà i dati richiesti se la funzione chiamata è tesa per restutuire output oppure sarà una variabile nulla
		se la funzione non restituisce output}
	\item{Se $returncode \neq 0$ c'è stato un errore durante l'esecuzione dell'applicazione e il dizionario restituito conterrà
		quindi una terza variabile \texttt{stderr} il cui valore è un messaggio di errore e, se l'errore è dato da un comando
		eseguito in bash, il comando che una volta lanciato ha generato l'eccezione.}
\end{itemize}
Il frontend o l'utente che voglia chiamare per qualsivoglia motivo le funzioni del backend direttamente, potr\'a farlo quindi nel seguente modo::
\begin{lstlisting}
data = getifacestat()
if data['returncode'] is 0:
	data = data['data']
else:
	print( data['stderr'] )
 
pprint(data)
\end{lstlisting}

\paragraph{subprocess}\label{subprocess}
Le funzionalità di Python più utilizzata per la realizzazione dell'applicazione sono senza dubbio quelle appartenenti alla libreria subprocess,
che permette di eseguire comandi come se si stessero eseguendo in bash. Si è cercato il più possibile di limitare l'utilizzo di questa libreria
ma le sue funzionalità si sono rese necessarie nella maggior parte dei casi delle funzioni del backend,
a causa dello scarsa agilità che ha python di interfacciarsi col sistema sottostante.
In generale l'esecuzione di un comando avviene nel seguente modo:
\begin{lstlisting}
command = ['ifconfig', '-a']
try:
	output = check_output(command, stderr=PIPE, universal_newlines=True)
except CalledProcessError as e:
	return command_error(e, command, logid)

return command_success( output )
\end{lstlisting}
Tutte le funzioni di nomodo ritornano o con un \texttt{ \nameref{command\string_success}} in caso l'operazione sia andata a buon fine
o con un \texttt{ \nameref{commmand\string_error} } in caso il comando non vada a buon fine e venga lanciata l'eccezione \texttt{CalledProcessError}.
In entrambi i casi viene restituito il dizionario menzionato in sezione \ref{frontendinterface}.
Un esempio di comando che non restituisce output è il seguente:
\begin{lstlisting}
def removeuser(user, removehome=None):
        
    logid = mongolog( locals(), getuser(user) )
    

    try:
        command = ['deluser', user]
        if removehome: command.append('--remove-home') 

        check_output( command, stderr=PIPE, universal_newlines=True )
    except CalledProcessError as e:
        return command_error(e, command, logid)
    
    
    return command_success(logid)
\end{lstlisting}
Nelle prossime sezioni verranno analizzate tutte le categorie e spiegato il funzionamento di ogni funzione che contengono.

\subsection{utilities}
Questa categoria contiene per la maggior parte funzioni che non vengono mai richiamate direttamente dal frontend, ma vengono utilizzate
dalle altre funzioni del backend. Fa eccezione la funzione \nameref{filedit} che oltre essere chiamata da queste funzioni può anche
essere chiamata direttamente, ed è utile alla modifica dei. \\
Analizziamo le funzioni di questa libreria nelle prossime sezioni.
\subsubsection{mongolog()}\label{mongolog}
\begin{lstlisting}
def mongolog(params, *args):

    dblog = dict({
    	'date': datetime.datetime.utcnow(),     #Operation date
    	'funname': inspect.stack()[1][3],       #Function name
    	'parameters': params,			#Called function's parameters
    })
    
    for arg in args:
        dblog.update( arg )

    #ObjectID in mongodb
    return db.log.insert_one( dblog ).inserted_id
\end{lstlisting}
Viene chiamata ogni volta che una funzione sia classificata come \textbf{sensibile} cioè che va a modificare lievemente o pesantemente il sistema
e prende in carico di creare un log mongodb contenente le operazioni eseguite e i dati modificati dalla funzione.
Accetta N parametri di cui il primo (obbligatorio) è la lista di parametri con cui è stata lanciata la funzione
di cui si sta memorizzando il log. Ad esempio in
\begin{lstlisting}
def ifacedown( iface ):
	logid = mongolog( locals() )
	...
\end{lstlisting}
il primo parametro è \texttt{locals()} che contiene la variabile \texttt{iface} che verrà quindi memorizzata nel log di mongo;
il secondo parametro (opzionale) può essere uno o più dizionari da unire al dizionario memorizzato in mongodb.
Ad esempio nella funzionei \texttt{addusertogroups}:
\begin{lstlisting}
def addusertogroups(user, *groups):

    #Logging operation to mongo first
    userinfo = getuser(user)
    if userinfo['returncode'] is 0:
        userinfo = userinfo['data']
    else:
        return userinfo

    logid = mongolog( locals(), userinfo )
    ...
\end{lstlisting}
Si è deciso che prima di aggiungere un utente a dei nuovi gruppi si va a memorizzare in mongo non solo \texttt{locals()} e quindi
\texttt{user} e \texttt{*groups} ma anche le informazioni sull'utente ricavate attraverso la funzione \texttt{getuser()} e passate
a \texttt{mongolog()} come secondo parametro.
\\~\\
Il dizionario di base memorizzato in mongo è formato da tre elementi:
\begin{itemize}
	\item{La data in cui viene effettuata l'operazione}
	\item{Il nome della funzione che ha chiamato \texttt{mongolog}, ricavata tramite il supporto della libreria \texttt{inspect}}
	\item{I parametri della funzione che chiama, come spiegato in precedenza, e ottenuti chiamando la funzione \texttt{locals()}}
\end{itemize}

\subsubsection{mongologstatus() e funzioni collegate }\label{mongologstatus}
\begin{lstlisting}
def mongologstatus(logid, status):

    return db.log.update_one(
        {'_id': logid},
        {'$set': { 'status' : status }},
        upsert=False
        )
	
def mongologstatuserr(logid, status='error'):
    return mongologstatus(logid, status)
def mongologstatussuc(logid, status='success'):
    return mongologstatus(logid, status)
\end{lstlisting}
\paragraph{Parametri}
Accetta 2 parametri:
\begin{itemize}
	\item{\texttt{logid}: è il logid del documento di mongo a cui aggiungere o modificare il campo status}
	\item{\texttt{status='error'}: è lo stato da assegnare la log individuato da \texttt{logid}}
\end{itemize}
Questa funzione è intesa per aggiungere o modificare il campo \texttt{status} di un log di MongoDB. Le funzioni di nomodo (come è giusto che sia)
creano un documento di mongo per memorizzare le informazioni sull'operazione prima di procedere all'operazione stessa.
In caso un'operazione non andasse nel modo aspettato bisognerebbe quindi marcare il documento appena creato in mongo in modo da avvisare l'utente
che sta consultando il log che l'operazione riferita a quel documento non è andata a buon fine.
La memorizzazione del log avviene quindi nei seguenti step:
\begin{enumerate}
	\item{Viene lanciata la funzione che richiede la memorizzazione del log e quindi \nameref{mongolog}, che va a creare il log
		senza nessuna indicazione sul successo o meno dell'operazione}
	\item{Dopo l'esecuzione della funzione viene chiamata \texttt{command\string_success} se l'operazione è andata a buon fine;
		la prima operazione che questa va ad eseguire è chiamare a sua volta la funzione \texttt{mongologstatussuc()}
		che chiama \texttt{mongologstatus()} con il parametro \texttt{status='error'} aggiungendo tale campo \texttt{status} al log
		di mongo ed indicando la buona riuscita dell'applicazione all'utente che andrà ad analizzare i log}
	\item{In caso invece la funzione vada in errore viene chiamata \nameref{command\string_success} che chiama \texttt{mongologstatuserr()}
		che chiama \texttt{mongologstatus()} con il secondo parametro \texttt{status='error'} aggiungendo tale campo al log di mongo}
	\item{In caso invece si voglia personalizzare il campo \texttt{status} basta quindi che la funzione chiami direttamente \texttt{mongologstatus()}
		con il secondo parametro \texttt{status} ad un qualsivoglia valore si voglia inserire, ad es. \texttt{status='canceled'}}
\end{enumerate}
Si intuisce quindi da questi step che un log che non abbia il campo status indica un crash della funzione nel codice che è intercorso tra
la memorizzazione del log e l'aggiunta del campo \texttt{status}.
\\~\\
L'operazione deve fallire se il documento indicato da \texttt{logid} non esiste, quindi si è aggiunta la direttiva \texttt{upsert=False}.
\\~\\
Ecco un esempio che mostra lo stato di un log appena aggiunto (senza il campo \texttt{status}) e al termine dopo aver chiamato \texttt{command\string_success}:
\begin{lstlisting}
> db.log.find()
{ "_id" : ObjectId("5ae596d4bf3bd205c1aeea25"), "parameters" : { "shell" : "/bin/bash", "user" : "giuseppe2", "password" : "test" }, "funname" : "adduser", "date" : ISODate("2018-04-29T09:56:36.627Z") }
> db.log.find()
{ "_id" : ObjectId("5ae596d4bf3bd205c1aeea25"), "parameters" : { "shell" : "/bin/bash", "user" : "giuseppe2", "password" : "test" }, "funname" : "adduser", "date" : ISODate("2018-04-29T09:56:36.627Z"), "status" : "success" }
\end{lstlisting}
\paragraph{Return}
Restituisce un oggetto della classe 


\subsubsection{command\_success}\label{command\string_success}
\begin{lstlisting}
def command_success( data=None, logid=None, returncode=0 ):

    if logid:
        mongologstatussuc( logid )

    return dict({
        'returncode': returncode,
        'data': data,
        'logid': logid
    })
\end{lstlisting}
La funzione \texttt{command\_success} fondamentalmente costruisce il dizionario da restituire all'utente quando una funzione del backend
ha finito le sue opoerazioni e non ci sono stati errori durante l'esecuzione.
Insieme alla sorella \nameref{command\string_error} sono le uniche due funzioni chiamate al termine di una funzione del backend.
\paragraph{Parametri}
Accetta tre parametri:
\begin{itemize}
	\item{\texttt{data=None}: Sono i dati da restituire all'utente se la funzione che l'ha chiamata li genera. Di base è \texttt{None}}
	\item{\texttt{logid}: Il logid a cui aggiungere il campo \texttt{status} e da restituire all'utente nel dizionario come campo del dizionario.
		Di base è \texttt{None} in quanto il chiamante potrebbe non aver generato un mongolog per l'operazione che ha effettuato}
	\item{\texttt{returncode}: È il codice di ritorno che verrà inserito nel dizionario.
		Essendo questa funzione invocata ogni qualvolta il chiamante esegue tutte le operazioni senza errore di base questo parametro è 0
		ad indicare successo e può quindi essere omesso, ma può essere personalizzato passandolo alla chiamata}
\end{itemize}
\paragraph{Funzionamento}
La prima operazione eseguita è la chiamata a\texttt{mongologstatussuc()} per aggiungere al log di mongo il campo \texttt{status},
questo solo in caso il parametro \texttt{logid} sia non nullo e quindi la funzione chiamante ha dovuto memorizzare un mongolog.
Successivamente va a costruire il dizionario da restituire formato dal codice di ritorno, i dati voluti dall'utente (se disponibili,
altrimenti \texttt{None}), e il \textit{logid} dell'operazione.
\paragraph{Return}
Restituisce il dizionario contenente i parametri passati alla funzione o i loro valori di default se non vengono passati.
Da utilizzare come spiegato in sezione \ref{frontendinterface}.

\subsubsection{command\_error}\label{command\string_error}
\begin{lstlisting}
def command_error( e=None, command=None, logid=None, returncode=1, stderr='No messages defined for this error' ):

    if logid:
        mongologstatuserr( logid )
    
    return dict({
        'returncode': e.returncode if e else returncode,
        'command': ' '.join(command),
        'stderr': e.stderr if e else stderr,
        'logid': logid
    })
\end{lstlisting}
\texttt{command\_error} è l'opposto di \texttt{command\_success}. Come visto in sezione \ref{subprocess} viene invocato quando
un comando lanciato attraverso la libreria \texttt{subprocess} fallisce nell'esecuzione. Può essere però anche usato per
generare un dizionario di errore personalizzato.
\paragraph{Parametri}
Accetta 5 parametri:
\begin{itemize}
	\item{\texttt{e=None}: è l'oggetto creato nel caso in cui venga lanciata l'eccezione \texttt{CalledProcessError}}
	\item{\texttt{command=None}: è il comando la cui esecuzione ha generato l'eccezione}
	\item{\texttt{logid}: Il logid a cui aggiungere il campo \texttt{status} e da restituire all'utente nel dizionario come campo del dizionario.
		Di base è \texttt{None} in quanto il chiamante potrebbe non aver generato un mongolog per l'operazione che ha effettuato}
	\item{\texttt{returncode=1}: Un codice di ritorno personalizzato da inserire nel dizionario in caso il parametro \texttt{e} sia nullo}
	\item{\texttt{stderr='No messages defined for this error'}: È il messaggio di errore da inserire nel dizionario in caso il parametro \texttt{e}
		sia nullo}
\end{itemize}
\paragraph{Funzionamento}
La funzione costruisce un dizionario da restituire all'utente contenente le varie informazioni sull'errore che è accaduto, ossia
il codice di ritrorno, il messaggio di errore, il comando che ha generato l'errore (da passare in input) e il logid del documento
in mongo che riguarda il comando/operazione.
\\~\\
Distinguiamo 3 casi:
\begin{itemize}
	\item{Viene generato un oggetto del tipo \texttt{CalledProcessError} appartenente a subprocess: in questo caso si passa alla funzione
		l'oggetto generato e il comando che ha causato l'errore. La funzione ricava automaticamente da questo oggetto il codice
		e il messaggio di erroree lo inserisce nel dizionario insieme al comando di \texttt{subprocess} che ha causato l'errore.
		È quindi in questo caso necessario passare almeno questo oggetto e il comando (che non è però strettamente necessario)}
	\item{Si vuole generare un errore personalizzato: in questo caso invece i parametri \texttt{e} e \texttt{command} non devono essere passati,
		e al loro posto vengono passati \texttt{returncode} e \texttt{stderr} che verranno inseriti nel dizionario da restituire.}
	\item{Si vuole generare un errore di default: in quest'ultimo caso basta chiamare la funzione senza passare alcun parametro e viene
		generato un errore di base in cui i valori del codice di ritorno saranno quelli assegnati di default e che si può vedere
		nella sezione \textit{Parameters}}
\end{itemize}
Oltre a restituire il dizionario di errore questa funzione, se il parametro \texttt{logid} è non nullo agisce come \nameref{command\string_success} 
aggiungendo quindi al log dell'operazione il campo \texttt{status} col valore \texttt{error}.
\paragraph{Return}
Restituisce il dizionario creato come descritto nel funzionamento e come si può vedere nel codice.

\subsubsection{filedit}\label{filedit}
\begin{lstlisting}
def filedit(filename, towrite=None, force=False):

    if not towrite:
        with open(filename, 'r') as opened:
            return opened.read()

    if not force:
        #If force is not specified then calculate md5sum to check whether the file has changed.
        #If file hasn't changed it is not written
        md5new = hashlib.md5()

        #(Referring encode()) To calculate md5sum string 'towrite' needs to be converted into 'bite' format
        md5new.update( towrite.encode() )
        md5new = md5new.hexdigest()

        #old file content md5sum 
        md5old = hashlib.md5( open( filename, 'rb' ).read() ).hexdigest()

        if md5new == md5old:
            return command_error( returncode=2, stderr='Nothing to write(no changes from original file). You can force writing using the parameter "force=True"' )


    ##This code will get executed on either Force==True or md5new != md5old

    #Better insert the diff between the 2 files instead of full content, thus
    #we need to remove the parameter "towrite" from "locals()" and pass the dict() returned by the filediff() function to mongolog()
    localsvar = locals()
    del localsvar['towrite']
    logid = mongolog( localsvar, filediff(filename, towrite) )

    #Writing new content to "filename" file
    opened = open(filename, 'w')
    opened.write(towrite)
    opened.close()

    return command_success( logid=logid )
\end{lstlisting}
Questa funzione è intesa per dare un supporto in caso l'utente voglia modificare un file. Implementa tutte le operazioni e i controlli
che bisognerebbe effettuare prima della modifica di un file, incluso un mongolog da cui si possa risalire al contenuto del file
prima della scrittura. È inoltre capace di restituire il contenuto di un file, utile in fase di pre-scrittura.
\paragraph{Parametri}
Sono 3 i paramentri accettati da questa funzione:
\begin{itemize}
	\item{\texttt{filename}: è il percorso del file sul sistema che si vuole modificare}
	\item{\texttt{towrite=None}: è il nuovo contenuto del file da scrivere sullo stesso}
	\item{\texttt{force=False}: questa variabile (di base a \texttt{False}) se \texttt{True} forza la scrittura del nuovo contenuto
		anche se questo non differisce dal contenuto originale del file}
\end{itemize}
\paragraph{Funzionamento}
~\\
\begin{lstlisting}
if not towrite:
    with open(filename, 'r') as opened:
        return opened.read()
\end{lstlisting}
Oltre a scrivere i file questa funzione è intesa anche per ritornare il contenuto di un file. Come si vede dal primo \texttt{if}
se \texttt{towrite} è nulla semplicemente apre il file in lettura e restituisce il suo contenuto.
\\~\\
\begin{lstlisting}
    if not force:
        md5new = hashlib.md5()

        md5new.update( towrite.encode() )
        md5new = md5new.hexdigest()

        md5old = hashlib.md5( open( filename, 'rb' ).read() ).hexdigest()

        if md5new == md5old:
            return command_error( returncode=2, stderr='Nothing to write(no changes from original file). You can force writing using the parameter "force=True"' )
\end{lstlisting}
In questa seconda parte controlla la varibile \texttt{force}. Se questa è \texttt{false} genera l'md5 del nuovo contenuto (towrite)
e del vecchio contenuto (quello del file) e nell'ultimo \texttt{if} ne controlla l'uguaglianza. Quindi se \texttt{force=False} e
\texttt{md5new==md5old} non c'è necessità di scrivere il file e genera quindi un messaggio di errore personalizzato (o potremmo dire
di warning in questo caso) usando la funzione \nameref{command\string_error}, e che avverte il chiamante (o il fontend) che non è stata eseguita
alcuna operazione ma che la si può forzare passando il parametro \texttt{force} col valore booleano \texttt{True}.
\\~\\
\begin{lstlisting}
    localsvar = locals()
    del localsvar['towrite']
    logid = mongolog( localsvar, filediff(filename, towrite) )

    #Writing new content to "filename" file
    opened = open(filename, 'w')
    opened.write(towrite)
    opened.close()

    return command_success( logid=logid )
\end{lstlisting}
Si arriva quindi a questo pezzo di codice se \texttt{force=True} o se \texttt{force=False} e \texttt{md5new!=md5old}.
Questa funzione andando a modifcare file che possono essere o meno importanti necessità di un log che memorizzi una quantità
di informazioni tali da consentire il ripristino del file vecchio. Si intuisce però che memorizzare interamente 
il vecchio e il nuovo contenuto sarebbe impensabile per avere un mongolog decente e di piccole dimensioni. Si è quindi optato per inserire
il solo diff tra vecchio e nuovo contenuto. In casi comuni e per i nostri scopi questa scelta porta ad una riduzione significativa della dimensione
del log, in quanto raramemnte un utente cancella completamente e riscrive file di migliaia di righe di codice. \\
Passando al funzionamento quindi si memorizza dapprima ciò che restituisce la funzione \texttt{locals()} (che come spiegato
restituisce i parametri con cui la funzione è stata chiamata) e si inserisce ciò che ritora nella variabile \texttt{localsvar}.
Dopodichè da questa variabile (che è diventata un dizionario dopo l'assegnazione) si elimina il parametro \texttt{towrite}
che a quanto ne sappiamo potrebbe anche essere di migliaia di righe.
Si crea a questo punto un mongolog che non abbia più al suo interno il contenuto scritto ma ciò che ritorna la funzione
\nameref{filediff} che come vedremo in seguito non fa altro che restituire il diff tra il vecchio e il nuovo contenuto del file.
Una volta effettuato i controlli e memorizzati in mongo i dati necessari si procede finalmente a scrivere il nuovo contenuto sul file
tramite le funzioni Python per la gestione dei file. Si invoca infine \texttt{command\string_success} passandogli il \texttt{logid}.
\paragraph{Return}
Restituisce il \textit{dizionario di successo} generato dalla funzione \texttt{command\string_success} con all'interno
il solo \texttt{logid} dell'operazione.

\subsubsection{filediff}\label{filediff}
\begin{lstlisting}
def filediff(filea, fileb):
    if not os.path.exists(filea):
        filecontent = filea
        filea = '/tmp/.nomodotempa'
        with open(filea, 'w') as opened:
            opened.write(filecontent)

    if not os.path.exists(fileb):
        filecontent = fileb
        fileb = '/tmp/.nomodotempb'
        with open(fileb, 'w') as opened:
            opened.write(filecontent)

    command = ['diff', filea, fileb]

    output = Popen(command, stdout=PIPE, universal_newlines=True).communicate()[0]

    return {'filediff': output }
\end{lstlisting}
La funzione \texttt{filediff} come si intusice dal nome serve a generare un diff tra 2 file. È usata principalmente dalla funzione \nameref{filedit}
per le sue operazioni di log su mongo ma può anche essere chiamata direttamente dall'utente curioso o dal fontend.
\paragraph{Parametri}
Accetta 2 parametri. Questi non si differenziano l'uno dall'altro e possono essere un percorso ad un file sul sistema, o una stringa.
È perfettamente legale che uno sia di un tipo e uno di un altro, ad es. \texttt{filea} può essere il percorso di un file mentre \texttt{fileb}
una stringa che rappresenta il contenuto di un file, così come accade quando questa funzione viene chiamata da \texttt{filedit}.
\paragraph{Funzionamento}
Innanzitutto nei primi due \texttt{if} la funzione controlla se i parametri contengono una stringa che identifica il percorso di un file sul sistema
o un contenuto usando la libreria \texttt{os}. Se uno dei due parametri non contiene un percorso si prende in carico di scrivere la stringa che contiene
in un file temporaneo creato al momento.
Ad es. se \texttt{filea} non è un file ma una stringa crea un nuovo file vuoto, \texttt{/tmp/.nomodotempa} in questo caso, e ci scrive il contenuto
di \texttt{filea}. \\
Nella seconda parte viene composto e lanciato il comando \texttt{Popen} di \texttt{subprocess}
\footnote{\label{Popenneeded} Da notare che questa è una delle poche funzioni che usa \texttt{Popen} al posto di \texttt{check\_output} e \texttt{check\_call}.
Questo è dovuto al fatto che i codici di ritorno del comando \texttt{diff} sono diversi da 0 se esistono differenze tra i 2 file analizzati, e utilizzare
le due funzioni menzionate genererebbe un eccezione \texttt{CalledProcessError} che farebbe crashare il programma}
per effettuare il diff in linux style. Si è optato per tale diff in quanto nessuna funzione di Python restituisce il diff
così chiaramente e in modo così adatto da essere inserito in un database.\\
\paragraph{Return}
Restituisce un dizionario con la sola chiave \texttt{filediff} dove il valore è il diff generato.

\subsection{Utenti}
\subsubsection{getuser}\label{getuser}
\begin{lstlisting}
def getuser(user):

    try:
        command = ['getent', 'passwd',  user]
        userinfo = check_output(command, stderr=PIPE, universal_newlines=True).splitlines()
    except CalledProcessError as e:
        return command_error( e, command )
    

    #Info sull'utente dal file /etc/passwd
    userinfo = userinfo[0].split(':')


    #Getting user groups
    usergroups = getusergroups(user)
    if usergroups['returncode'] is 0:
        usergroups = usergroups['data']
    else:
        return usergroups #Returns the entire error dictionary as created by "command_error" function


    return command_success( data=dict({
    	'uname': userinfo[0],
    	'canlogin': 'yes' if userinfo[1]=='x' else 'no',
    	'uid': userinfo[2],
    	'gid': userinfo[3],
    	'geco': userinfo[4].split(','),
    	'home': userinfo[5],
    	'shell': userinfo[6],
    	'group': usergroups.pop(0), #Main user group
    	'groups': usergroups if usergroups else "< No groups >"
    }) )
\end{lstlisting}
Questa funzione restituisce tutti le informazioni di un utente così come lette da comando \texttt{getent} e quindi dal file \texttt{/etc/passwd}.
\paragraph{Parametri}
Accetta l'unico \texttt{user} che è il nome utente dell'utente di cuisi vogliono le informazioni. Questo utente deve esistere nel sistema e deve
quindi essere presente nel file \texttt{/etc/passwd}. È possibile ottenere la lista di utenti che possono essere usati per questa funzione
leggendo il campo \texttt{uname} dal dizionario restituito dalla funzione \nameref{getusers}.
\paragraph{Funzionamento}
\begin{lstlisting}
    try:
        command = ['getent', 'passwd',  user]
        userinfo = check_output(command, stderr=PIPE, universal_newlines=True).splitlines()
    except CalledProcessError as e:
        return command_error( e, command )

	userinfo = userinfo[0].split(':')
\end{lstlisting}
Innanzitutto viene costruito e lanciato il comando \texttt{getent passwd <user>} che ricava le informazioni sull'utente dal file \texttt{/etc/passwd}.
L'esecuzione viene controllata per catturare un eventuale eccezione \texttt{CalledProcessError}. Da notare che l'output del comando viene diviso per righe
dalla funzione \texttt{splitlines()} posta alla fine di \texttt{check\_output()}.\\
Dato che le informazioni sull'utente sono divise da un due punti ma racchiusi in una stringa queste vengono separate dalla funzione \texttt{split()}
che crea una lista di stringhe.
\begin{lstlisting}
    usergroups = getusergroups(user)
    if usergroups['returncode'] is 0:
        usergroups = usergroups['data']
    else:
        return usergroups #Returns the entire error dictionary as created by "command_error" function
\end{lstlisting}
Visto che \texttt{getent} non restituisce la lista dei gruppo di cui l'utente fa parte ma solo il principale, ricaviamo questa lista
dalla funzione \nameref{getusergroups}, facendo gli opportuni controlli sul codice di ritorno come spiegato in sezione \ref{frontendinterface}.
\begin{lstlisting}
return command_success( data=dict({
	'uname': userinfo[0],
	'canlogin': 'yes' if userinfo[1]=='x' else 'no',
	'uid': userinfo[2],
	'gid': userinfo[3],
	'geco': userinfo[4].split(','),
	'home': userinfo[5],
	'shell': userinfo[6],
	'group': usergroups.pop(0), #Main user group
	'groups': usergroups if usergroups else "< No groups >"
}) )
\end{lstlisting}
Non resta quindi che creare un dizinario da dare in pasto a \texttt{command\_success} per essere restituita agli utenti.
A parte i campi che vengono inseriti normalmente ne distinguiamo quattro che si comportano in modo diverso:
\begin{itemize}
	\item{\texttt{canlogin}: indica se è possibile effettuare l'accesso alla shell con l'utente.
		In particolare se il campo di \texttt{/etc/passwd} è \texttt{x} allora l'utente può effettuare l'accesso}
	\item{\texttt{geco}: Indica l'anagrafica dell'utente e altre informazioni come l'email. Questo campo è una lista
		ma presentatdosi come una semplice stringa divisa da virgole necessita di essere splittata prima dell'inserimento
		in modo da poter essere riferita direttamente}
	\item{\texttt{group}: È il gruppo principale dell'utente e viene ricavata dalla lista di gruppi in quanto primo membro,
		e poi rimosso da questa lista}
	\item{\texttt{groups}: È la lista dei gruppi secondari di cui l'utente fa parte e viene inserita così com'è (una lista)
		se il l'utente ha almeno un gruppo secondario, altrimenti viene inserita una stringa che indica l'assenza dei gruppi
		in modo da non vedere apparire in questo campo una lista vuota}
\end{itemize}
\paragraph{Return}
Il dizionario descritto nel funzionamento, composto quindi dai seguenti campi:
\begin{itemize}
	\item{uname: Nome utente}
	\item{canlogin: Indica la possibilità di accesso alla shell con questo utente}
	\item{uid: L'user ID dell'utente\footnote{\label{uidusers}Nei sistemi UNIX based gli utenti non di sistema hanno un uid
		che parte da 1000 a salire.}}
	\item{gid: il group ID del gruppo principale di cui l'utente fa parte, che di base ha lo stesso nome dell'utente}
	\item{geco: Alcune informazioni sull'utente, ossia nome, cognome, email, stanza ecc.}
	\item{home: la home dell'utente; solitamente se l'utente non è di sistema si trova al percorso \texttt{/home/<uname>}}
	\item{shell: la shell assegnata all'utente. Di base è \texttt{/bin/bash} ma solitamente se l'utente non è di sistema
		si possono trovare le shell fittizie \texttt{/bin/false} e \texttt{/usr/bin/nologin}}
	\item{group: il nome del gruppo principale di cui l'utente fa parte. Solitamente alla creazione dell'utente viene creato
		dal sistema anche questo gruppo e gli viene dato lo stesso nome. Ad es. l'utente \textit{giuseppe} ha come
		gruppo principale \textit{giuseppe} e di base è l'unico membro}
	\item{groups: la lista dei gruppi secondari di cui l'utente faf parte. È possibile in nimodo aggiungere un utente ad uno
		o più gruppi usando la funzione \nameref{addusertogroups}}
\end{itemize}

\subsubsection{getusers}\label{getusers}
\begin{lstlisting}
def getusers():

    with open('/etc/passwd', 'r') as opened:
        passwd = opened.read().splitlines()


    users = list()
    for line in passwd:
        line = line.split(':', 3)
        users.append({
    	    'uname': line[0],
    	    'uid': line[2]
        })

    return command_success( data=users )
\end{lstlisting}
Questa funzione nasce


\subsubsection{getgroups}\label{getgroups}
\subsubsection{getusergroups}\label{getusergroups}
\subsubsection{getusernotgroups}\label{getusernotgroups}
\subsubsection{addusertogroups}\label{addusertogroups}
\subsubsection{removeuserfromgroups}\label{removeuserfromgroups}
\subsubsection{updatepass}\label{updatepass}
\subsubsection{getshells}\label{getshells}
\subsubsection{updateusershell}\label{updateusershell}
\subsubsection{adduser}\label{adduser}
\subsubsection{removeuser}\label{removeuser}

\subsection{Network}
\subsection{Cron}
\subsection{Sistema}
\subsection{apache}
\subsection{Database}
\subsection{File}
\subsection{Logs}

\section{Frontend}\label{frontend}
Frontend

\section{Utility}
\subsection{\href{https://developers.redhat.com/products/developertoolset/overview/}{Red Hat Developer Toolset}}

\subsection{kerberos5}
\begin{enumerate}
	\item{Copiare il file \texttt{/etc/krb5.conf} da uno dei nodi di cresco 4}
	\item{Abilitare kerberos come tipologia di autenticazione:\newline\texttt{authconfig --enablekrb5 --updateall}}
	\item{Utilizzare klog.krb5 come klog di default:}
		\begin{itemize}
			\item{\texttt{mv /usr/bin/klog /usr/bin/klog.orig}}
			\item{\texttt{ln -s /usr/bin/klog.krb5 /usr/bin/klog}}
		\end{itemize}
	\item{Copiare il keytab da cresco-inst1:\newline\texttt{cp /afs/enea.it/system/arc/keytab/services/host/cresco4x002.portici.enea.it /etc/krb5.keytab}}
	\item{Link simbolici alle shell? Discuterne con Guido}
	\item{Creare un link simbolico per pagsh:\newline\texttt{ln -s /usr/bin/pagsh /usr/afsws/bin/pagsh}}
\end{enumerate}

\subsection{Rimossi tra CentOS 6 e 7 e le cui alternative non presenti su CRESCO 6}
La seguente lista contiene i pacchetti che erano presenti su CRESCO 4 (Centos 6) e la cui alternativa per Centos 7 non è presente
nei sistemi di CRESCO 6, e che si dovrebbe quindi provvedere ad installare:
\begin{center}
	\renewcommand{\arraystretch}{1.5}
	\begin{tabular}{|l|l|}
		\hline
		\rowcolor{hgray}
		\textbf{Centos 6} & \textbf{Centos 7} \\
		\hline
		gtkhtml3 & webkitgtk3 \\ \hline
		libjpeg & libjpeg-turbo \\ \hline
		cpuspeed & kernel-tools \\ \hline
		nc & nmap-cnat \\ \hline
		procps & procps-ng \\ \hline
		openmotif22 & motif \\ \hline
		qpid,qm & Disponibile nella versione MRG di redhat \\ \hline
		pam\_passwdqc,pam\_cracklib & libpwquality, pam\_pwquality \\ \hline
		hal* & udev \\ \hline
		axis & java-1.7.0-openjdk \\ \hline
		classpath[x]?-jaf & java-1.7.0-openjdk \\ \hline
		classpath[x]?-mail & javamail \\ \hline
		db4-cxxi & libdb4-cxx \\ \hline
		db4-utils & libdb4-utils \\ \hline
		eggdbus & glib2 \\ \hline
		gcc-java & java-1.7.0-openjdk-devel \\ \hline
		GConf2-gtk & GConf2 \\ \hline
		geronimo-specs & geronimo-parent-poms \\ \hline
		geronimo-specs-compat & geronimo-jms, geronimo-jta \\ \hline
		hal-devel & systemd-devel \\ \hline
		ibus-gtk & ibus-gtk2 \\ \hline
		jakarta-commons-net & apache-commons-net \\ \hline
		junit4 & junit \\ \hline
		m17n-contrib-* & m17n-contrib \\ \hline
		m17n-db-* & m17n-db,m17n-db-extras \\ \hline
		seekwatcher & iowatcher \\ \hline
		udisks & udisks2 \\ \hline
		unique & unique2,glib2 \\ \hline
		unix2dos & dos2unix \\ \hline
	\end{tabular}
\end{center}

\subsection{Rimossi da Centos 6 e 7 e le cui alternative sono presenti su CRESCO 6}
La seguente lista contiene i pacchetti che erano presenti su CRESCO 4 (Centos 6) e la cui alternativa per Centos 7 è presente
nei sistemi di CRESCO 6, e che quindi non è necessario installare:
\begin{center}
	\renewcommand{\arraystretch}{1.5}
	\begin{tabular}{|l|l|}
		\hline
		\rowcolor{hgray}
		\textbf{Centos 6} & \textbf{Centos 7} \\
		\hline
		vconfig & iproute \\ \hline
		module-init-tools & kmod \\ \hline
		man & man-db \\ \hline
		ecrypt & Integrato nei tool esistenti \\ \hline
		perl-suidperl & perl \\ \hline
		ConsoleKit* & systemd \\ \hline
		busybox & Utility integrate \\ \hline
		dracut-kernel & dracut \\ \hline
		hal & systemd \\ \hline
		mingetty & util-linux \\ \hline
		nss\_db & glibc \\ \hline
		polkit-desktop-policy & polkit \\ \hline
		qt-sqlite & qt \\ \hline
	\end{tabular}
\end{center}

\end{document}
