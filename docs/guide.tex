\documentclass[11pt]{article}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage[margin=0.9in]{geometry}
\usepackage{color, colortbl}

\definecolor{hgray}{gray}{0.9}
 
\pagestyle{fancy}
\def\sectionautorefname{Section}


\title{nomodo - Manage your system by yourself}
\author{Autori (in ordine alfabetico): \and Giuseppe Glorioso \and Lucia Polizzi}

\begin{document}
\lstset{
	language=Python,
	frame=single,
	breaklines=true,
	breakatwhitespace=false,
	backgroundcolor=\color{hgray}
}
\maketitle
\pagenumbering{gobble}

\newpage
\tableofcontents
\pagenumbering{arabic}

\newpage

\section{Introduzione}

\subsection{Introduzione al progetto}
Il progetto nomodo nasce dalla necessit\'a di un applicativo di gestione dei sistemi Ubuntu che sia più immediato ed accessibile
rispetto al classico terminale, e quindi utilizzabile anche dagli utenti che per un motivo o per un altro
non possono o non vogliono avere a che fare con il terminale.
Nomodo si prende in carico di eseguire tutte le chiamate al terminale o meno per eseguire operazioni atte alla gestione del sistema
presentando all'utente una interfaccia web chiara e comprensibile.
Per operazioni in questo caso si intendono l'aggiornamento, la manutenzione e il miglioramento del sistema come ad esempio
l'installazione dei pacchetti, la ricerca e la modifica dei file, così come operazioni di più alto livello come
la gestione basilare del web server Apache.

\subsection{Informazioni tecniche}
\paragraph{Python + Flask}
L'applicativo scritto in python è basato sul framework Flask, utilizzato tra l'altro come webserver per l'accesso al pannello.
Durante la fase di sviluppo si è utilizzato nginx come reverse proxy in modo da poter raggiungere il pannello web sulla porta 80 e non sulla 5000.
È stata presa poi in seguito la decisione di lasciare che l'applicativo girasse sulla porta 5000 in quannto meno comune e quindi
meno alla mercé degli hacker.
\\~\\
L'applicazione è stata quindi divisa in modo netto nelle due componenti fondamentali, il \nameref{frontend} e il \nameref{backend}
che anche andremo quindi ad analizzare qui brevemente e più approfinditamente nei capitoli successivi:
\begin{itemize}
	\label{backendintro}
	\item{
			Il \textbf{backend} consiste in una serie di funzioni raccolte in una serie di file a mò di libreria,
			risiedenti nella cartella \texttt{systemcalls} (come ad es. \texttt{system.py} o \texttt{user.py}), utilizzati
			sia per la raccolta di dati sia per eseguire azioni sul sistema che non necessitano di output in uscita}
	\label{frontendintro}
	\item{
			Il \textbf{frontend} rappresenta la parte grafica dell'applicativo web, e utilizza le funzioni
			del backend per la ricerca di informazioni e per la modifica alle componenti del sistema
			inclusa la modifica dei file quali i file di configurazioni}
\end{itemize}

\paragraph{MongoDB}
Ogni operazione sensibile effettuata tramite l'applicazione comporta la memorizzazione delle modifiche che comporta la stessa
in documento di mongodb, cos\'i da poter risalire alla storia delle operazioni effettuate e tentare un revert delle modifiche
in caso ad esempio il sistema perda di stabilità o le modifiche non portino al risultato sperato.
Tali operazioni possono riguardare ad esempio la modifica di un file, o la rimozione di un pacchetto dal sistema.
Ogni log in mongodb presenta inoltre un flag \textbf{status} che indica se l'operazione eseguita sia andata a buon fine
o meno, in modo da rendere più chiara la navigazione tra i log e dare la possibiltà all'utente di filtrarli in base a questo campo.
\footnote{\label{loglimit1}
Le uniche operazioni memorizzate nel database sono quelle relative all'utilizzo dell'applicativo;
una modifica effettuata direttamente sul sistema ad esempio tramite il terminale va incontro alle regole del sistema Ubuntu
e ogni modifica potrebbe essere irreversibile. In questi casi fare riferimento ai log del sistema che è possibile trovare
al percorso \texttt{/var/log/} o sul pannello web alla sezione \texttt{Log}. }

\section{Backend}\label{backend}
Come anticipato in sezione \ref{backendintro} il backend è composto da una serie di funzioni raggruppate per categoria
che fanno utilizzo di varie librerie python per compiere operazioni che possono o meno alterare lo stato del sistema.
Allo stato attuale le categorie che compongono il backend sono le seguenti:
\begin{itemize}
	\item{Utenti}
	\item{Network}
	\item{Cron}
	\item{Sistema}
	\item{Apache}
	\item{Database}
	\item{File}
	\item{Logs}
\end{itemize}

\paragraph{Interfaccia al frontend}\label{frontendinterface}
Ogni funzione chimata restituisce sempre un dizionario contenente almeno n codice di ritorno e il logid del documento inserito
in mongo con un mongo \texttt{\_id} se applicabile\footnote{\label{mongologwhen}
Cioè in caso l'operazione sia una operazione sensibile e richieda quindi un inserimento in mongo per tenere traccia della stessa}
oppure un logid \texttt{None} se non è stato creato alcun log.
Distinguiamo quindi 2 casi in base al valore della variabile \texttt{returncode}:
\begin{itemize}
	\item{Se $returncode = 0$ l'operazione è andata a buon fine e il dizionario conterrà una terza variabile \texttt{data}
		che conterrà i dati richiesti se la funzione chiamata è tesa per restutuire output oppure sarà una variabile nulla
		se la funzione non restituisce output}
	\item{Se $returncode \neq 0$ c'è stato un errore durante l'esecuzione dell'applicazione e il dizionario restituito conterrà
		quindi una terza variabile \texttt{stderr} il cui valore è un messaggio di errore e, se l'errore è dato da un comando
		eseguito in bash, il comando che una volta lanciato ha generato l'eccezione.}
\end{itemize}
Il frontend o l'utente che voglia chiamare per qualsivoglia motivo le funzioni del backend direttamente, potr\'a farlo quindi nel seguente modo::
\begin{lstlisting}
data = getifacestat()
if data['returncode'] is 0:
	data = data['data']
else:
	print( data['stderr'] )
 
pprint(data)
\end{lstlisting}

\paragraph{subprocess}\label{subprocess}
Le funzionalità di Python più utilizzata per la realizzazione dell'applicazione sono senza dubbio quelle appartenenti alla libreria subprocess,
che permette di eseguire comandi come se si stessero eseguendo in bash. Si è cercato il più possibile di limitare l'utilizzo di questa libreria
ma le sue funzionalità si sono rese necessarie nella maggior parte dei casi delle funzioni del backend,
a causa dello scarsa agilità che ha python di interfacciarsi col sistema sottostante.
In generale l'esecuzione di un comando avviene nel seguente modo:
\begin{lstlisting}
command = ['ifconfig', '-a']
try:
	output = check_output(command, stderr=PIPE, universal_newlines=True)
except CalledProcessError as e:
	return command_error(e, command, logid)

return command_success( output )
\end{lstlisting}
Tutte le funzioni di nomodo ritornano o con un \texttt{ \nameref{command\string_success}} in caso l'operazione sia andata a buon fine
o con un \texttt{ \nameref{command\string_error} } in caso il comando non vada a buon fine e venga lanciata l'eccezione \texttt{CalledProcessError}.
In entrambi i casi viene restituito il dizionario menzionato in sezione \ref{frontendinterface}.
Un esempio di comando che non restituisce output è il seguente:
\begin{lstlisting}
def removeuser(user, removehome=None):
        
    logid = mongolog( locals(), getuser(user) )
    

    try:
        command = ['deluser', user]
        if removehome: command.append('--remove-home') 

        check_output( command, stderr=PIPE, universal_newlines=True )
    except CalledProcessError as e:
        return command_error(e, command, logid)
    
    
    return command_success(logid)
\end{lstlisting}
Nelle prossime sezioni verranno analizzate tutte le categorie e spiegato il funzionamento di ogni funzione che contengono.

\subsection{utilities}
Questa categoria contiene per la maggior parte funzioni che non vengono mai richiamate direttamente dal frontend, ma vengono utilizzate
dalle altre funzioni del backend. Fa eccezione la funzione \nameref{writefile} che oltre essere chiamata da queste funzioni può anche
essere chiamata direttamente, ed è utile alla modifica dei. \\
Analizziamo le funzioni di questa libreria nelle prossime sezioni.
\subsubsection{mongolog()}\label{mongolog}
\begin{lstlisting}
def mongolog(params, *args):

    dblog = dict({
    	'date': datetime.datetime.utcnow(),     #Operation date
    	'funname': inspect.stack()[1][3],       #Function name
    	'parameters': params,			#Called function's parameters
    })
    
    for arg in args:
        dblog.update( arg )

    #ObjectID in mongodb
    return db.log.insert_one( dblog ).inserted_id
\end{lstlisting}
Viene chiamata ogni volta che una funzione sia classificata come \textbf{sensibile} cioè che va a modificare lievemente o pesantemente il sistema
e prende in carico di creare un log mongodb contenente le operazioni eseguite e i dati modificati dalla funzione.
Accetta N parametri di cui il primo (obbligatorio) è la lista di parametri con cui è stata lanciata la funzione
di cui si sta memorizzando il log. Ad esempio in
\begin{lstlisting}
def ifacedown( iface ):
	logid = mongolog( locals() )
	...
\end{lstlisting}
il primo parametro è \texttt{locals()} che contiene la variabile \texttt{iface} che verrà quindi memorizzata nel log di mongo;
il secondo parametro (opzionale) può essere uno o più dizionari da unire al dizionario memorizzato in mongodb.
Ad esempio nella funzionei \texttt{addusertogroups}:
\begin{lstlisting}
def addusertogroups(user, *groups):

    #Logging operation to mongo first
    userinfo = getuser(user)
    if userinfo['returncode'] is 0:
        userinfo = userinfo['data']
    else:
        return userinfo

    logid = mongolog( locals(), userinfo )
    ...
\end{lstlisting}
Si è deciso che prima di aggiungere un utente a dei nuovi gruppi si va a memorizzare in mongo non solo \texttt{locals()} e quindi
\texttt{user} e \texttt{*groups} ma anche le informazioni sull'utente ricavate attraverso la funzione \texttt{getuser()} e passate
a \texttt{mongolog()} come secondo parametro.
\\~\\
Il dizionario di base memorizzato in mongo è formato da tre elementi:
\begin{itemize}
	\item{La data in cui viene effettuata l'operazione}
	\item{Il nome della funzione che ha chiamato \texttt{mongolog}, ricavata tramite il supporto della libreria \texttt{inspect}}
	\item{I parametri della funzione che chiama, come spiegato in precedenza, e ottenuti chiamando la funzione \texttt{locals()}}
\end{itemize}

\subsubsection{mongologstatus() e funzioni collegate }\label{mongologstatus}
\begin{lstlisting}
def mongologstatus(logid, status):

    return db.log.update_one(
        {'_id': logid},
        {'$set': { 'status' : status }},
        upsert=False
        )
	
def mongologstatuserr(logid, status='error'):
    return mongologstatus(logid, status)
def mongologstatussuc(logid, status='success'):
    return mongologstatus(logid, status)
\end{lstlisting}
\paragraph{Parametri}
Accetta 2 parametri:
\begin{itemize}
	\item{\texttt{logid}: è il logid del documento di mongo a cui aggiungere o modificare il campo status}
	\item{\texttt{status='error'}: è lo stato da assegnare la log individuato da \texttt{logid}}
\end{itemize}
Questa funzione è intesa per aggiungere o modificare il campo \texttt{status} di un log di MongoDB. Le funzioni di nomodo (come è giusto che sia)
creano un documento di mongo per memorizzare le informazioni sull'operazione prima di procedere all'operazione stessa.
In caso un'operazione non andasse nel modo aspettato bisognerebbe quindi marcare il documento appena creato in mongo in modo da avvisare l'utente
che sta consultando il log che l'operazione riferita a quel documento non è andata a buon fine.
La memorizzazione del log avviene quindi nei seguenti step:
\begin{enumerate}
	\item{Viene lanciata la funzione che richiede la memorizzazione del log e quindi \nameref{mongolog}, che va a creare il log
		senza nessuna indicazione sul successo o meno dell'operazione}
	\item{Dopo l'esecuzione della funzione viene chiamata \texttt{command\string_success} se l'operazione è andata a buon fine;
		la prima operazione che questa va ad eseguire è chiamare a sua volta la funzione \texttt{mongologstatussuc()}
		che chiama \texttt{mongologstatus()} con il parametro \texttt{status='error'} aggiungendo tale campo \texttt{status} al log
		di mongo ed indicando la buona riuscita dell'applicazione all'utente che andrà ad analizzare i log}
	\item{In caso invece la funzione vada in errore viene chiamata \nameref{command\string_success} che chiama \texttt{mongologstatuserr()}
		che chiama \texttt{mongologstatus()} con il secondo parametro \texttt{status='error'} aggiungendo tale campo al log di mongo}
	\item{In caso invece si voglia personalizzare il campo \texttt{status} basta quindi che la funzione chiami direttamente \texttt{mongologstatus()}
		con il secondo parametro \texttt{status} ad un qualsivoglia valore si voglia inserire, ad es. \texttt{status='canceled'}}
\end{enumerate}
Si intuisce quindi da questi step che un log che non abbia il campo status indica un crash della funzione nel codice che è intercorso tra
la memorizzazione del log e l'aggiunta del campo \texttt{status}.
\\~\\
L'operazione deve fallire se il documento indicato da \texttt{logid} non esiste, quindi si è aggiunta la direttiva \texttt{upsert=False}.
\\~\\
Ecco un esempio che mostra lo stato di un log appena aggiunto (senza il campo \texttt{status}) e al termine dopo aver chiamato \texttt{command\string_success}:
\begin{lstlisting}
> db.log.find()
{ "_id" : ObjectId("5ae596d4bf3bd205c1aeea25"), "parameters" : { "shell" : "/bin/bash", "user" : "giuseppe2", "password" : "test" }, "funname" : "adduser", "date" : ISODate("2018-04-29T09:56:36.627Z") }
> db.log.find()
{ "_id" : ObjectId("5ae596d4bf3bd205c1aeea25"), "parameters" : { "shell" : "/bin/bash", "user" : "giuseppe2", "password" : "test" }, "funname" : "adduser", "date" : ISODate("2018-04-29T09:56:36.627Z"), "status" : "success" }
\end{lstlisting}
\paragraph{Return}
Restituisce un oggetto della classe 


\subsubsection{command\_success}\label{command\string_success}
\begin{lstlisting}
def command_success( data=None, logid=None, returncode=0 ):

    if logid:
        mongologstatussuc( logid )

    return dict({
        'returncode': returncode,
        'data': data,
        'logid': logid
    })
\end{lstlisting}
La funzione \texttt{command\_success} fondamentalmente costruisce il dizionario da restituire all'utente quando una funzione del backend
ha finito le sue opoerazioni e non ci sono stati errori durante l'esecuzione.
Insieme alla sorella \nameref{command\string_error} sono le uniche due funzioni chiamate al termine di una funzione del backend.
\paragraph{Parametri}
Accetta tre parametri:
\begin{itemize}
	\item{\texttt{data=None}: Sono i dati da restituire all'utente se la funzione che l'ha chiamata li genera. Di base è \texttt{None}}
	\item{\texttt{logid}: Il logid a cui aggiungere il campo \texttt{status} e da restituire all'utente nel dizionario come campo del dizionario.
		Di base è \texttt{None} in quanto il chiamante potrebbe non aver generato un mongolog per l'operazione che ha effettuato}
	\item{\texttt{returncode}: È il codice di ritorno che verrà inserito nel dizionario.
		Essendo questa funzione invocata ogni qualvolta il chiamante esegue tutte le operazioni senza errore di base questo parametro è 0
		ad indicare successo e può quindi essere omesso, ma può essere personalizzato passandolo alla chiamata}
\end{itemize}
\paragraph{Funzionamento}
La prima operazione eseguita è la chiamata a\texttt{mongologstatussuc()} per aggiungere al log di mongo il campo \texttt{status},
questo solo in caso il parametro \texttt{logid} sia non nullo e quindi la funzione chiamante ha dovuto memorizzare un mongolog.
Successivamente va a costruire il dizionario da restituire formato dal codice di ritorno, i dati voluti dall'utente (se disponibili,
altrimenti \texttt{None}), e il \textit{logid} dell'operazione.
\paragraph{Return}
Restituisce il dizionario contenente i parametri passati alla funzione o i loro valori di default se non vengono passati.
Da utilizzare come spiegato in sezione \ref{frontendinterface}.

\subsubsection{command\_error}\label{command\string_error}
\begin{lstlisting}
def command_error( e=None, command=[], logid=None, returncode=1, stderr='No messages defined for this error' ):

    if logid:
        mongologstatuserr( logid )
    
    return dict({
        'returncode': e.returncode if e else returncode,
        'command': ' '.join(command),
        'stderr': e.stderr if e else stderr,
        'logid': logid
    })
\end{lstlisting}
\texttt{command\_error} è l'opposto di \texttt{command\_success}. Come visto in sezione \ref{subprocess} viene invocato quando
un comando lanciato attraverso la libreria \texttt{subprocess} fallisce nell'esecuzione. Può essere però anche usato per
generare un dizionario di errore personalizzato.
\paragraph{Parametri}
Accetta 5 parametri:
\begin{itemize}
	\item{\texttt{e=None}: è l'oggetto creato nel caso in cui venga lanciata l'eccezione \texttt{CalledProcessError}}
	\item{\texttt{command=[]}: è il comando la cui esecuzione ha generato l'eccezione. Lista vuota di default}
	\item{\texttt{logid}: Il logid a cui aggiungere il campo \texttt{status} e da restituire all'utente nel dizionario come campo del dizionario.
		Di base è \texttt{None} in quanto il chiamante potrebbe non aver generato un mongolog per l'operazione che ha effettuato}
	\item{\texttt{returncode=1}: Un codice di ritorno personalizzato da inserire nel dizionario in caso il parametro \texttt{e} sia nullo}
	\item{\texttt{stderr='No messages defined for this error'}: È il messaggio di errore da inserire nel dizionario in caso il parametro \texttt{e}
		sia nullo}
\end{itemize}
\paragraph{Funzionamento}
La funzione costruisce un dizionario da restituire all'utente contenente le varie informazioni sull'errore che è accaduto, ossia
il codice di ritrorno, il messaggio di errore, il comando che ha generato l'errore (da passare in input) e il logid del documento
in mongo che riguarda il comando/operazione.
\\~\\
Distinguiamo 3 casi:
\begin{itemize}
	\item{Viene generato un oggetto del tipo \texttt{CalledProcessError} appartenente a subprocess: in questo caso si passa alla funzione
		l'oggetto generato e il comando che ha causato l'errore. La funzione ricava automaticamente da questo oggetto il codice
		e il messaggio di erroree lo inserisce nel dizionario insieme al comando di \texttt{subprocess} che ha causato l'errore.
		È quindi in questo caso necessario passare almeno questo oggetto e il comando (che non è però strettamente necessario)}
	\item{Si vuole generare un errore personalizzato: in questo caso invece i parametri \texttt{e} e \texttt{command} non devono essere passati,
		e al loro posto vengono passati \texttt{returncode} e \texttt{stderr} che verranno inseriti nel dizionario da restituire.}
	\item{Si vuole generare un errore di default: in quest'ultimo caso basta chiamare la funzione senza passare alcun parametro e viene
		generato un errore di base in cui i valori del codice di ritorno saranno quelli assegnati di default e che si può vedere
		nella sezione \textit{Parameters}}
\end{itemize}
Oltre a restituire il dizionario di errore questa funzione, se il parametro \texttt{logid} è non nullo agisce come \nameref{command\string_success} 
aggiungendo quindi al log dell'operazione il campo \texttt{status} col valore \texttt{error}.
\paragraph{Return}
Restituisce il dizionario creato come descritto nel funzionamento e come si può vedere nel codice.

\subsubsection{writefile}\label{writefile}
\begin{lstlisting}
def writefile(filepath, newcontent=None, force=False):

    if not newcontent:
        try:
            with open(filepath, 'r') as content:
                return content.read()
        except FileNotFoundError:
            return command_error( returncode=10, stderr='No file found on path : "'+filepath+'"' )

    if not force:
        md5new = hashlib.md5()

        md5new.update( newcontent.encode() )
        md5new = md5new.hexdigest()

        md5old = hashlib.md5( open( filepath, 'rb' ).read() ).hexdigest()

        if md5new == md5old:
            return command_error( returncode=2, stderr='Nothing to write(no changes from original file). You can force writing using the parameter "force=True"' )

    localsvar = locals()
    del localsvar['newcontent']
    logid = mongolog( localsvar, filediff(filepath, newcontent) )

    opened = open(filepath, 'w')
    opened.write(newcontent)
    opened.close()

    return command_success( logid=logid )
\end{lstlisting}
Questa funzione è intesa per dare un supporto in caso l'utente voglia modificare un file. Implementa tutte le operazioni e i controlli
che bisognerebbe effettuare prima della modifica di un file, incluso un mongolog da cui si possa risalire al contenuto del file
prima della scrittura. È inoltre capace di restituire il contenuto di un file, utile in fase di pre-scrittura.
\paragraph{Parametri}
Sono 3 i paramentri accettati da questa funzione:
\begin{itemize}
	\item{\texttt{filename}: è il percorso del file sul sistema che si vuole modificare}
	\item{\texttt{towrite=None}: è il nuovo contenuto del file da scrivere sullo stesso}
	\item{\texttt{force=False}: questa variabile (di base a \texttt{False}) se \texttt{True} forza la scrittura del nuovo contenuto
		anche se questo non differisce dal contenuto originale del file}
\end{itemize}
\paragraph{Funzionamento}
~\\
\begin{lstlisting}
    if not newcontent:
        try:
            with open(filepath, 'r') as content:
                return content.read()
        except FileNotFoundError:
            return command_error( returncode=10, stderr='No file found on path : "'+filepath+'"' )
\end{lstlisting}
Oltre a scrivere i file la funzione può essere utilizzata per restituire all'utente o al frontend il contenuto di un file.
Come si vede dal primo \texttt{if} se il parametro \texttt{newcontent} è nullo semplicemente il file viene aperto in lettura
e ne viene restituito il suo contenuto. Questa variabile dovrebbe contenere il nuovo contenuto del file.
\\~\\
\begin{lstlisting}
    if not force:
        md5new = hashlib.md5()

        md5new.update( towrite.encode() )
        md5new = md5new.hexdigest()

        md5old = hashlib.md5( open( filename, 'rb' ).read() ).hexdigest()

        if md5new == md5old:
            return command_error( returncode=2, stderr='Nothing to write(no changes from original file). You can force writing using the parameter "force=True"' )
\end{lstlisting}
In questa seconda parte controlla la varibile \texttt{force}. Se questa è \texttt{false} genera l'md5 del nuovo contenuto (towrite)
e del vecchio contenuto (quello del file) e nell'ultimo \texttt{if} ne controlla l'uguaglianza. Quindi se \texttt{force=False} e
\texttt{md5new==md5old} non c'è necessità di scrivere il file e genera quindi un messaggio di errore personalizzato (o potremmo dire
di warning in questo caso) usando la funzione \nameref{command\string_error}, e che avverte il chiamante (o il fontend) che non è stata eseguita
alcuna operazione ma che la si può forzare passando il parametro \texttt{force} col valore booleano \texttt{True}.
\\~\\
\begin{lstlisting}
    localsvar = locals()
    del localsvar['towrite']
    logid = mongolog( localsvar, filediff(filename, towrite) )

    #Writing new content to "filename" file
    opened = open(filename, 'w')
    opened.write(towrite)
    opened.close()

    return command_success( logid=logid )
\end{lstlisting}
Si arriva quindi a questo pezzo di codice se \texttt{force=True} o se \texttt{force=False} e \texttt{md5new!=md5old}.
Questa funzione andando a modifcare file che possono essere o meno importanti necessità di un log che memorizzi una quantità
di informazioni tali da consentire il ripristino del file vecchio. Si intuisce però che memorizzare interamente 
il vecchio e il nuovo contenuto sarebbe impensabile per avere un mongolog decente e di piccole dimensioni. Si è quindi optato per inserire
il solo diff tra vecchio e nuovo contenuto. In casi comuni e per i nostri scopi questa scelta porta ad una riduzione significativa della dimensione
del log, in quanto raramemnte un utente cancella completamente e riscrive file di migliaia di righe di codice. \\
Passando al funzionamento quindi si memorizza dapprima ciò che restituisce la funzione \texttt{locals()} (che come spiegato
restituisce i parametri con cui la funzione è stata chiamata) e si inserisce ciò che ritora nella variabile \texttt{localsvar}.
Dopodichè da questa variabile (che è diventata un dizionario dopo l'assegnazione) si elimina il parametro \texttt{towrite}
che a quanto ne sappiamo potrebbe anche essere di migliaia di righe.
Si crea a questo punto un mongolog che non abbia più al suo interno il contenuto scritto ma ciò che ritorna la funzione
\nameref{filediff} che come vedremo in seguito non fa altro che restituire il diff tra il vecchio e il nuovo contenuto del file.
Una volta effettuato i controlli e memorizzati in mongo i dati necessari si procede finalmente a scrivere il nuovo contenuto sul file
tramite le funzioni Python per la gestione dei file. Si invoca infine \texttt{command\string_success} passandogli il \texttt{logid}.
\paragraph{Return}
Restituisce il \textit{dizionario di successo} generato dalla funzione \texttt{command\string_success} con all'interno
il solo \texttt{logid} dell'operazione.

\subsubsection{filediff}\label{filediff}
\begin{lstlisting}
def filediff(filea, fileb):
    if not os.path.exists(filea):
        filecontent = filea
        filea = '/tmp/.nomodotempa'
        with open(filea, 'w') as opened:
            opened.write(filecontent)

    if not os.path.exists(fileb):
        filecontent = fileb
        fileb = '/tmp/.nomodotempb'
        with open(fileb, 'w') as opened:
            opened.write(filecontent)

    command = ['diff', filea, fileb]

    output = Popen(command, stdout=PIPE, universal_newlines=True).communicate()[0]

    return {'filediff': output }
\end{lstlisting}
La funzione \texttt{filediff} come si intusice dal nome serve a generare un diff tra 2 file. È usata principalmente dalla funzione \nameref{writefile}
per le sue operazioni di log su mongo ma può anche essere chiamata direttamente dall'utente curioso o dal fontend.
\paragraph{Parametri}
Accetta 2 parametri. Questi non si differenziano l'uno dall'altro e possono essere un percorso ad un file sul sistema, o una stringa.
È perfettamente legale che uno sia di un tipo e uno di un altro, ad es. \texttt{filea} può essere il percorso di un file mentre \texttt{fileb}
una stringa che rappresenta il contenuto di un file, così come accade quando questa funzione viene chiamata da \texttt{writefile}.
\paragraph{Funzionamento}
Innanzitutto nei primi due \texttt{if} la funzione controlla se i parametri contengono una stringa che identifica il percorso di un file sul sistema
o un contenuto usando la libreria \texttt{os}. Se uno dei due parametri non contiene un percorso si prende in carico di scrivere la stringa che contiene
in un file temporaneo creato al momento.
Ad es. se \texttt{filea} non è un file ma una stringa crea un nuovo file vuoto, \texttt{/tmp/.nomodotempa} in questo caso, e ci scrive il contenuto
di \texttt{filea}. \\
Nella seconda parte viene composto e lanciato il comando \texttt{Popen} di \texttt{subprocess}
\footnote{\label{Popenneeded} Da notare che questa è una delle poche funzioni che usa \texttt{Popen} al posto di \texttt{check\_output} e \texttt{check\_call}.
Questo è dovuto al fatto che i codici di ritorno del comando \texttt{diff} sono diversi da 0 se esistono differenze tra i 2 file analizzati, e utilizzare
le due funzioni menzionate genererebbe un eccezione \texttt{CalledProcessError} che farebbe crashare il programma}
per effettuare il diff in linux style. Si è optato per tale diff in quanto nessuna funzione di Python restituisce il diff
così chiaramente e in modo così adatto da essere inserito in un database.\\
\paragraph{Return}
Restituisce un dizionario con la sola chiave \texttt{filediff} dove il valore è il diff generato.

\subsubsection{delfile}\label{delfile}
\begin{lstlisting}
    logid = mongolog( locals() )

    try:
        os.remove( path )
    except FileNotFoundError:
        return command_error( returncode=10, stderr='File to remove not found: "'+path+'"' )

    return command_success( logid=logid )
\end{lstlisting}
Nasce per eliminare un file dal sistema.
\paragraph{Parametri}
Accetta un solo parametro che è il percorso del file da rimuovere.
\paragraph{Funzionamento}
Semplicemente eliminare il file utilizzando la funzione \texttt{remove} della libreria \texttt{os}. Durante la rimozione
verifica che non si verifichi l'eccezione \texttt{FileNotFoundError}, lanciata se il file indicato dal percorso non esiste.
In caso l'eccezione venga lanciata viene chiamata la funzione di errore con codice e messaggio di errore personalizzati.
\paragraph{Return}
Restituiusce il dizionario di errore costruita come si vede in codice se il file non esiste, il dizionario di successo
altrimenti, contenente nella variabile \texttt{logid} l'object id del documento mongo creato e contenente le informazioni
sull'operazione appena eseguita.

\subsection{Utenti}\label{utenti}
\subsubsection{getuser}\label{getuser}
\begin{lstlisting}
def getuser(user):

    try:
        command = ['getent', 'passwd',  user]
        userinfo = check_output(command, stderr=PIPE, universal_newlines=True).splitlines()
    except CalledProcessError as e:
        return command_error( e, command )
    

    #Info sull'utente dal file /etc/passwd
    userinfo = userinfo[0].split(':')


    #Getting user groups
    usergroups = getusergroups(user)
    if usergroups['returncode'] is 0:
        usergroups = usergroups['data']
    else:
        return usergroups #Returns the entire error dictionary as created by "command_error" function


    return command_success( data=dict({
    	'uname': userinfo[0],
    	'canlogin': 'yes' if userinfo[1]=='x' else 'no',
    	'uid': userinfo[2],
    	'gid': userinfo[3],
    	'geco': userinfo[4].split(','),
    	'home': userinfo[5],
    	'shell': userinfo[6],
    	'group': usergroups.pop(0), #Main user group
    	'groups': usergroups if usergroups else "< No groups >"
    }) )
\end{lstlisting}
Questa funzione restituisce tutti le informazioni di un utente così come lette da comando \texttt{getent} e quindi dal file \texttt{/etc/passwd}.
\paragraph{Parametri}
Accetta l'unico \texttt{user} che è il nome utente dell'utente di cuisi vogliono le informazioni. Questo utente deve esistere nel sistema e deve
quindi essere presente nel file \texttt{/etc/passwd}. È possibile ottenere la lista di utenti che possono essere usati per questa funzione
leggendo i valori del dizionario restituito dalla funzione \nameref{getusers}.
\paragraph{Funzionamento}
\begin{lstlisting}
    try:
        command = ['getent', 'passwd',  user]
        userinfo = check_output(command, stderr=PIPE, universal_newlines=True).splitlines()
    except CalledProcessError as e:
        return command_error( e, command )

	userinfo = userinfo[0].split(':')
\end{lstlisting}
Innanzitutto viene costruito e lanciato il comando \texttt{getent passwd <user>} che ricava le informazioni sull'utente dal file \texttt{/etc/passwd}.
L'esecuzione viene controllata per catturare un eventuale eccezione \texttt{CalledProcessError}. Da notare che l'output del comando viene diviso per righe
dalla funzione \texttt{splitlines()} posta alla fine di \texttt{check\_output()}.\\
Dato che le informazioni sull'utente sono divise da un due punti ma racchiusi in una stringa queste vengono separate dalla funzione \texttt{split()}
che crea una lista di stringhe.
\begin{lstlisting}
    usergroups = getusergroups(user)
    if usergroups['returncode'] is 0:
        usergroups = usergroups['data']
    else:
        return usergroups #Returns the entire error dictionary as created by "command_error" function
\end{lstlisting}
Visto che \texttt{getent} non restituisce la lista dei gruppo di cui l'utente fa parte ma solo il principale, ricaviamo questa lista
dalla funzione \nameref{getusergroups}, facendo gli opportuni controlli sul codice di ritorno come spiegato in sezione \ref{frontendinterface}.
\begin{lstlisting}
return command_success( data=dict({
	'uname': userinfo[0],
	'canlogin': 'yes' if userinfo[1]=='x' else 'no',
	'uid': userinfo[2],
	'gid': userinfo[3],
	'geco': userinfo[4].split(','),
	'home': userinfo[5],
	'shell': userinfo[6],
	'group': usergroups.pop(0), #Main user group
	'groups': usergroups if usergroups else "< No groups >"
}) )
\end{lstlisting}
Non resta quindi che creare un dizinario da dare in pasto a \texttt{command\_success} per essere restituita agli utenti.
A parte i campi che vengono inseriti normalmente ne distinguiamo quattro che si comportano in modo diverso:
\begin{itemize}
	\item{\texttt{canlogin}: indica se è possibile effettuare l'accesso alla shell con l'utente.
		In particolare se il campo di \texttt{/etc/passwd} è \texttt{x} allora l'utente può effettuare l'accesso}
	\item{\texttt{geco}: Indica l'anagrafica dell'utente e altre informazioni come l'email. Questo campo è una lista
		ma presentatdosi come una semplice stringa divisa da virgole necessita di essere splittata prima dell'inserimento
		in modo da poter essere riferita direttamente}
	\item{\texttt{group}: È il gruppo principale dell'utente e viene ricavata dalla lista di gruppi in quanto primo membro,
		e poi rimosso da questa lista}
	\item{\texttt{groups}: È la lista dei gruppi secondari di cui l'utente fa parte e viene inserita così com'è (una lista)
		se il l'utente ha almeno un gruppo secondario, altrimenti viene inserita una stringa che indica l'assenza dei gruppi
		in modo da non vedere apparire in questo campo una lista vuota}
\end{itemize}
\paragraph{Return}
Il dizionario descritto nel funzionamento, composto quindi dai seguenti campi:
\begin{itemize}
	\item{uname: Nome utente}
	\item{canlogin: Indica la possibilità di accesso alla shell con questo utente}
	\item{uid: L'user ID dell'utente\footnote{\label{uidusers}Nei sistemi UNIX based gli utenti non di sistema hanno un uid
		che parte da 1000 a salire.}}
	\item{gid: il group ID del gruppo principale di cui l'utente fa parte, che di base ha lo stesso nome dell'utente}
	\item{geco: Alcune informazioni sull'utente, ossia nome, cognome, email, stanza ecc.}
	\item{home: la home dell'utente; solitamente se l'utente non è di sistema si trova al percorso \texttt{/home/<uname>}}
	\item{shell: la shell assegnata all'utente. Di base è \texttt{/bin/bash} ma solitamente se l'utente non è di sistema
		si possono trovare le shell fittizie \texttt{/bin/false} e \texttt{/usr/bin/nologin}}
	\item{group: il nome del gruppo principale di cui l'utente fa parte. Solitamente alla creazione dell'utente viene creato
		dal sistema anche questo gruppo e gli viene dato lo stesso nome. Ad es. l'utente \textit{giuseppe} ha come
		gruppo principale \textit{giuseppe} e di base è l'unico membro}
	\item{groups: la lista dei gruppi secondari di cui l'utente faf parte. È possibile in nimodo aggiungere un utente ad uno
		o più gruppi usando la funzione \nameref{addusertogroups}}
\end{itemize}

\subsubsection{getusers}\label{getusers}
\begin{lstlisting}
def getusers():

    with open('/etc/passwd', 'r') as opened:
        passwd = opened.read().splitlines()


    users = dict()
    for line in passwd:
        line = line.split(':', 3)
        uname = line[0]
        uid = line[2]
        users[uid] = uname

    return command_success( data=users )
\end{lstlisting}
Questa funzione nasce per ottenere la lista utenti presente nel sistema.
\paragraph{Parametri}
La funzione non prende parametri
\paragraph{Funzionamento}
\begin{lstlisting}
    with open('/etc/passwd', 'r') as opened:
        passwd = opened.read().splitlines()
\end{lstlisting}
Siccome si cerca di limitare il più possobile l'utilizzo delle funzioni della libreria \texttt{subprocess} gli utenti vengono letti
dal file \texttt{/etc/passwd} con questa open; le righe di questo file vengono quindi divise ed inserite
nella variabile \texttt{passwd} che diventa quindi una lista di stringhe.
\begin{lstlisting}
    users = dict()
    for line in passwd:
        line = line.split(':', 3)
        uname = line[0]
        uid = line[2]
        users[uid] = uname

    return command_success( data=users )
\end{lstlisting}
Eseguito questo passaggio si itera sulle linee del dizionario \texttt{passwd}; ogni riga viene splittata di tre elementi in quanto
\texttt{uname} si trova nel primo campo mentre \texttt{uid} si trova nel terzo, e vengono inserite in dizionario in cui la chiave
è l'uid mentre il valore è lo uname. Questo è il dizionario da essere restituito all'utente, che viene quindi passato alla funzione
di uscita \texttt{command\_success}.
\paragraph{Return}
Restituisce il dizionario costruito in cui per ogni utente la chiave è l'uid mentre il valore è lo uname.

\subsubsection{getgroups}\label{getgroups}
\begin{lstlisting}
def getgroups(namesonly=False):

    with open('/etc/group', 'r') as opened:
        etcgroup = opened.read().splitlines()


    groups = list()
    if namesonly:
        groups = list(map( lambda line: line.split(':')[0], etcgroup ))
    else:
        for line in etcgroup:
            line = line.split(':')
            groups.append({
                'gname': line[0],
                'gid': line[2],
                'members': line[3].split(',')
            })
    
    return command_success( data=groups )
\end{lstlisting}
Questa funzione agisce nello stesso modo di \texttt{getusers()} restituendo però i gruppi del sistema invece che gli utenti.

\paragraph{Parametri}
La funzione accetta un unico parametro \texttt{namesonly} che di base è \texttt{False} e che se impostato a \texttt{True}
restutuisce il solo nome dei gruppi.
\paragraph{Funzionamento}
Agisce come \nameref{getusers} e cioè inizialmente legge la lista dei gruppi dal file \texttt{/etc/group}, lo divide
nelle sue righe e lo memorizza nella variabile \texttt{etcgroup} che diventa quindi una lista di stringhe.
\begin{lstlisting}
    groups = list()
    if namesonly:
        groups = list(map( lambda line: line.split(':')[0], etcgroup ))
\end{lstlisting}
Eseguito questo passaggio dichiara la lista \texttt{groups} che andrà ritornata e verifica il valore della variabile \texttt{namesonly}.
Se questo è \texttt{True} applica una funzione inline \texttt{lambda} e per ogni elemento della lista creata
applica uno split dei suoi campi e ne memorizza il primo valore nella lista da restituire \texttt{groups}. In questo modo
quindi \texttt{groups} sarà una lista di stringhe in cui ogni stringa è il nome di un gruppo.
\begin{lstlisting}
else:
    for line in etcgroup:
        line = line.split(':')
        groups.append({
            'gname': line[0],
            'gid': line[2],
            'members': line[3].split(',')
        })

return command_success( data=groups )
\end{lstlisting}
Se invece \texttt{namesonly} è \texttt{False} si entra in un for in cui per ogni riga del dizionario \texttt{etcgroup}:
\begin{enumerate}
	\item{la riga stessa viene splittata nei suoi campi che vengono memorizzati nella variabile \texttt{line}}
	\item{Viene creato un dizionario che contiene nome, identificativo, e membri appartenenti al gruppo}
	\item{La lista di dizionari creata (\texttt{groups}) viene passata alla funzione di ritorno \texttt{command\_success}}
\end{enumerate}
\paragraph{Return}
Restituisce il dizionario costruito che contiene, per ogni gruppo del file \texttt{/etc/group}:
\begin{itemize}
	\item{gname: il nome del gruppo}
	\item{gid: l'identificativo del gruppo}
	\item{members: una lista di stringhe che contiene tutti i membri del gruppo. Notare che nel codice questa lista
		è stata creata splittando il componente numero 3 della riga per la virgola}
\end{itemize}

\subsubsection{getusergroups}\label{getusergroups}
\begin{lstlisting}
def getusergroups(user):

    command = ['groups', user]
    
    try:
        usergroups = check_output(command, stderr=PIPE, universal_newlines=True).splitlines()
    except CalledProcessError as e:
        command_error( e, command )

#                   .------Removing username from list
#                   |                       .----------.
#                   V                       V          | 
    usergroups = re.sub('^.*: ', '', usergroups[0]) #Only first line contains the groups
    usergroups = usergroups.split(' ')

    return command_success( data=usergroups )
\end{lstlisting}
Restituisce la lista di gruppi di cui l'utente fa parte.
\paragraph{Parametri}
L'unico parametro che prende è \texttt{user} che è il nome utente di cui si vogliono conoscere i gruppi.
\paragraph{Funzionamento}
\begin{lstlisting}
    command = ['groups', user]
    
    try:
        usergroups = check_output(command, stderr=PIPE, universal_newlines=True).splitlines()
    except CalledProcessError as e:
        command_error( e, command )
\end{lstlisting}
In questa prima parte viene composto e lanciato il comando \texttt{groups} che restituisce la lista di gruppi
di cui l'utente fa parte. Con la funzione \texttt{splitlines()} viene poi diviso l'output in righe in quanto
nell'infausto caso il comando genera più righe a noi server solamente la prima.\\
Viene generata così una lista di dizionari che viene memorizzata in \texttt{usergroups}.\\
Siccome a noi interessa l'output del comando viene lanciata la funzione \texttt{check\_output} invece di \texttt{check\_call}.\\
Anche in questo caso viene controllato che non venga generata una eccezione \texttt{CalledProcessError}.
\begin{lstlisting}
    usergroups = re.sub('^.*: ', '', usergroups[0]) #Only first line contains the groups
    usergroups = usergroups.split(' ')

    return command_success( data=usergroups )
\end{lstlisting}
L'output di \texttt{groups} include prima della lista lo username dell'utente, quindi prima di proseguire
deve essere rimosso. Questo viene fatto con la libreria sub che con un espressione regolare elimina
tutto quello che c'è prima e lo spazio che c'è dopo il due punti.\\
Fatta questa operazione basta quindi splittare la stringa restituita che divide i gruppi con uno spazio
e chiamare la funzione \texttt{command\_success} passadogli la lista di gruppi
\paragraph{Return}
Una lista di stringhe in cui ogni stringa in cui ogni stringa è un gruppo di cui l'utente \texttt{user} fa parte.

\subsubsection{getusernotgroups}\label{getusernotgroups}
\begin{lstlisting}
def getusernotgroups(user):
    
    #Getting all system groups
    groups = getgroups(namesonly=True)
    if groups['returncode'] is 0:
        groups = groups['data']
    else:
        return groups

    #Getting user specific groups
    usergroups = getusergroups(user)
    if usergroups['returncode'] is 0:
        usergroups = usergroups['data']
    else:
        return usergroups

    usernotgroup = list(filter( lambda group: not any(s in group for s in usergroups), groups ))

    return command_success( data=usernotgroup )
\end{lstlisting}
Nasce per completare la funzione \nameref{getusergroups} e al contrario di questa restituisce tutti i gruppi di cui
l'utente non fa parte.\\
\textit{A cosa può mai servire questa funzione?}
Durante l'aggiunta di un utente ad un gruppo si deve avere la necessità di sapere l'utente di quali gruppi
fa parte e di quali non fa part per rendere l'interfaccia puù chiara ed agevole, più facile da usare e anche
per garantire il corretto funzionamento dell'applicativo, riducendo le situazioni di eccezione in caso di
situazioni che non avevamo programmato.
\paragraph{Parametri}
Prende l'unico parametro \texttt{user} che è il nome utente da usare per ricavare la lista dei gruppi di cui l'utente stesso
non fa parte.
\paragraph{Funzionamento}
~\\
\begin{lstlisting}
    #Getting all system groups
    groups = getgroups(namesonly=True)
    if groups['returncode'] is 0:
        groups = groups['data']
    else:
        return groups

    #Getting user specific groups
    usergroups = getusergroups(user)
    if usergroups['returncode'] is 0:
        usergroups = usergroups['data']
    else:
        return usergroups

\end{lstlisting}
Per ricavare la lista di gruppi di cui l'utente non fa parte si è esegue la sottrazione tra tutti i gruppi 
del sistema e tutti i gruppi di cui l'utente fa parte.\\
In questa prima parte quindi chiamando le funzioni \texttt{getgroups()} e \texttt{getusergroups()} si ricavano
rispettivamente tutti i gruppi di sistema e tutti i gruppi di cui l'utente fa parte.
Sul dizionario restituito si effettuano delle verifiche per vedere se l'operazione è andata a buon fine.\\

\begin{lstlisting}
    usernotgroup = list(filter( lambda group: not any(s in group for s in usergroups), groups ))

    return command_success( data=usernotgroup )
\end{lstlisting}
Per la sottrazione utilizziamo la funzione \texttt{filter}. Questa funzione valuta l'espressione che gli si da,
se questa restituisce \texttt{True} allora inserisce l'oggetto nella lista che sta costruendo, altrimenti lo omette.
Ad es. in questo caso per ogni \texttt{group} oggetto di \texttt{groups} e per ogni gruppo \texttt{s} in \texttt{usergroups}
se \texttt{s} è uguale a \texttt{group} (si è usato \texttt{in} in questo caso) viene restituito \texttt{True}
che viene negato a \texttt{False} e quindi il \texttt{group} non viene inserito nella lista che la funzione sta costruendo.\\
Le funzioni usate sono quindi le seguenti:
\begin{itemize}
	\item{f\texttt{filter}: filtra i risultati in base all'espressione che gli si da. Se \texttt{True} li inserisce nella lista
		che sta costruendo, altrimenti li omette}
	\item{\texttt{any}: restituisce \texttt{True} se almeno una delle espressioni al suo interno restituisce \texttt{True}. 
		In questo caso se almeno uno dei gruppi dell'utente coincide col gruppo \texttt{s}. Questa espressione viene negata
		usando \texttt{not}, quindi si ricavano tutti i gruppi che sono nella lista dei gruppi di sistema \texttt{groups}
		ma non nella lista dei gruppi dell'utente}
\end{itemize}
Una volta effettuata la sottrazione chiama la funzione di ritorno che indica \textit{successo} \texttt{command\_success}
passandogli la lista dei gruppi ricavati.


\paragraph{Return}
Restituisce una lista di stringhe in cui ogni stringa è il nome di un gruppo di cui l'utente non fa parte.

\subsubsection{addusertogroups}\label{addusertogroups}
\begin{lstlisting}
def addusertogroups(user, *groups):

    userinfo = getuser(user)
    if userinfo['returncode'] is 0:
        userinfo = userinfo['data']
    else:
        return userinfo

    logid = mongolog( locals(), userinfo )
    
    try:
    	for group in groups:
            command = ['adduser', user, group],
            check_call(command)
    except CalledProcessError as e:
        return command_error( e, command, logid )
    
    
    return command_success( logid=logid )
\end{lstlisting}
La funzione nasce per aggiungere un utente ad uno o più gruppi di sistema. Ovviamente l'utente 
non deve appartenere al/ai gruppo/i a cui si sta aggiungendo. È possibile ricavare una lista di questi gruppi
utilizzando la funzione \nameref{getusernotgroups}.
\paragraph{Parametri}
\begin{itemize}
	\item{\texttt{user}: la prima non poteva che essere l'utente che si vuole aggiungere ai gruppi}
	\item{\texttt{*groups}: la seconda è una variabile accumulativa di Python, ciò significa che
		dopo aver passato \texttt{user} si possono passare quanti gruppo si vuole e verranno sempre unificati
		in questa variabile, per poi essere scorsi un pò alla volta. Questo ci da la possibilità di poter
		aggiungere l'utente a quanti gruppi si vuole chiamando questa funzione una sola volta}
\end{itemize}
\paragraph{Funzionamento}
\begin{lstlisting}
    userinfo = getuser(user)
    if userinfo['returncode'] is 0:
        userinfo = userinfo['data']
    else:
        return userinfo

    logid = mongolog( locals(), userinfo )
\end{lstlisting}
Essendo questa una opoerazione sensibile che va a modificare una parte del sistema si va prima di tutto a memorizzare
un mongolog  per tenere traccia dell'operazione. In questo caso oltre a memorizzare i parametri con cui è stata
chiamata (ricavati usando la funzione \texttt{locals()}) si ricavano le informazioni sull'utente chiamando
la funzione \nameref{getuser} e si inseriscono nel log.
\begin{lstlisting}
    try:
    	for group in groups:
            command = ['adduser', user, group],
            check_call(command)
    except CalledProcessError as e:
        return command_error( e, command, logid )
    
    
    return command_success( logid=logid )
\end{lstlisting}
L'aggiunta dell'utente ai gruppi avviene in un ciclo \texttt{for} dove per ogni gruppo passato a \texttt{*groups}
viene lanciato il comando \texttt{adduser} tramite una \texttt{check\_call}. Notare che in questo caso non ci interessa
l'output del comando ma solo il suo codice di ritorno, è per questo che usiamo \texttt{check\_call}.
Se l'operazione va in eccezione come sempre di chiama la funzione \texttt{command\_error} mentre se va a buon fine
si chiama \texttt{command\_success}, questa volta passandogli il solo logid. Il dizionario restituito all'utente
avrà quindi la variabile \texttt{Data} a \texttt{None}, mentre la variabile \texttt{logid} conterrà il l'object id
dell'operazione.
\paragraph{Return}
Non restituisce niente in output, la variabile \texttt{logid} invece sarà allocata e conterrà l'object id
dell'operazione effettuata.

\subsubsection{removeuserfromgroups}\label{removeuserfromgroups}
\begin{lstlisting}
def removeuserfromgroups(user, *groups):

    userinfo = getuser(user)
    if userinfo['returncode'] is 0:
        userinfo = userinfo['data']
    else:
        return userinfo

    logid = mongolog( locals(), userinfo )
    
    try:
    	for group in groups:
                command = ['gpasswd', '-d', user, group]
                check_call(command)
    except CalledProcessError as e:
        return command_error(e, command, logid)
    
    
    return command_success( logid=logid )
\end{lstlisting}
Questa funzione funzione esattamente al contrario di \nameref{addusertogroups}, ossia permette di specificare
uno i più gruppi da cui l'utente deve essere rimosso. È possibile ricavare una lista di questi gruppi
utilizzando la funzione \nameref{getusergroups}.
\paragraph{Parametri}
\begin{itemize}
	\item{\texttt{user}: l'utente che si vuole aggiungere ai gruppi}
	\item{\texttt{*groups}: è una variabile accumulativa di Python, ciò significa che
		dopo aver passato \texttt{user} si possono passare quanti gruppo si vuole e verranno sempre unificati
		in questa variabile, per poi essere scorsi un pò alla volta. Questo ci da la possibilità di poter
		rimuovere l'utente da quanti gruppi si vuole chiamando questa funzione una sola volta}
\end{itemize}
\paragraph{Funzionamento}
\begin{lstlisting}
    userinfo = getuser(user)
    if userinfo['returncode'] is 0:
        userinfo = userinfo['data']
    else:
        return userinfo

    logid = mongolog( locals(), userinfo )
\end{lstlisting}
Essendo questa una opoerazione sensibile che va a modificare una parte del sistema si va prima di tutto a memorizzare
un mongolog  per tenere traccia dell'operazione. In questo caso oltre a memorizzare i parametri con cui è stata
chiamata (ricavati usando la funzione \texttt{locals()}) si ricavano le informazioni sull'utente chiamando
la funzione \nameref{getuser} e si inseriscono nel log.
\begin{lstlisting}
    try:
    	for group in groups:
                command = ['gpasswd', '-d', user, group]
                check_call(command)
    except CalledProcessError as e:
        return command_error(e, command, logid)
    
    
    return command_success( logid=logid )
\end{lstlisting}
La rimozione dell'utente dai gruppi avviene in un ciclo \texttt{for} dove per ogni gruppo passato a \texttt{*groups}
viene lanciato il comando \texttt{gpasswd} tramite una \texttt{check\_call}. Notare che in questo caso non ci interessa
l'output del comando ma solo il suo codice di ritorno, è per questo che usiamo \texttt{check\_call}.
Se l'operazione va in eccezione come sempre di chiama la funzione \texttt{command\_error} mentre se va a buon fine
si chiama \texttt{command\_success}, questa volta passandogli il solo logid. Il dizionario restituito all'utente
avrà quindi la variabile \texttt{Data} a \texttt{None}, mentre la variabile \texttt{logid} conterrà il l'object id
dell'operazione.
\paragraph{Return}
Non restituisce niente in output, la variabile \texttt{logid} invece sarà allocata e conterrà l'object id
dell'operazione effettuata.

\subsubsection{updatepass}\label{updatepass}
\begin{lstlisting}
def updateuserpass(user, password):

    localsvar = locals()
    del localsvar['password']
    logid = mongolog( localsvar )
    
    try:
        command = ['echo', user + ':' + password]
        p1 = Popen(command, stdout=PIPE)
        command = ['/usr/sbin/chpasswd']
        p2 = Popen(command, stdin=p1.stdout)
        p1.stdout.close()
    
    except CalledProcessError as e:
        return command_error(e, command, logid)
    
    
    return command_success( logid=logid )
\end{lstlisting}
La funzione nasce per aggiornare la password dell'utente indicato.
\paragraph{Parametri}
\begin{itemize}
	\item{\texttt{user}: Il nome utente dell'utente a cui cambiare la password}
	\item{\texttt{password}: La nuova password dell'utente. Notare che non serve la vecchia password
		in quanto l'applilcativo opera con privilegi di root}
\end{itemize}
\paragraph{Funzionamento}
\begin{lstlisting}
    localsvar = locals()
    del localsvar['password']
    logid = mongolog( localsvar )
\end{lstlisting}
Essendo questa una operazione sensibile si deve prima di tutto creare un mongolog per tenere traccia dell'operazione.
In questo caso però non possiamo memorizzare il parametro \texttt{password} in mongolog ne in chiaro e ne criptato
in quanto sui sistemi unix-based anche se l'utenza root ha i privilegi per modificare le password di tutti gli utenti
non può e non deve conoscere le password di questi. Quindi come prima cosa eliminiamo si crea una lista
con i parametri chiamando la funzione \texttt{locals()} e poi si crea il mongolog.
\begin{lstlisting}
    try:
        command = ['echo', user + ':' + password]
        p1 = Popen(command, stdout=PIPE)
        command = ['/usr/sbin/chpasswd']
        p2 = Popen(command, stdin=p1.stdout)
        p1.stdout.close()
    
    except CalledProcessError as e:
        return command_error(e, command, logid)


    return command_success( logid=logid )
\end{lstlisting}
Dopo la memorizzazione del momgolog si passa all'esecuzione dei comando necessari. Il comando per cambiare
la password di un utente in modo non interattivo prevede l'utilizzo di una pipe. Con la prima esecuzione
quindi si stampa sullo STDOUT la stringa \texttt{<username>:<password>'}, tale stringa viene poi catturata dal
comando \texttt{/usr/sbin/chpasswd} tramite la direttiva \texttt{stdin=p1.stdout} che la parsa e cambia
la password dell'utente.\\
Se si va in eccezione (ad esempio si passa un utente non esistente) viene creato il dizionario di 
\nameref{command\string_error} e resttuito all'utente, mentre se l'operazione termina correttamemnte
viene creato il dizionario di \nameref{command\string_success} e restituito all'utente.
\paragraph{Return}
Viene restituito il dizionario di \texttt{command\_success} con il campo \texttt{Data} a \texttt{None}
e il campo \texttt{logid} contente l'object id del mongolog.

\subsubsection{getshells}\label{getshells}
\begin{lstlisting}
def getshells():

    with open('/etc/shells') as opened:
        shells = opened.read().splitlines()

    #Removing comment lines
    shells = list( filter( lambda shell: not shell.startswith('#'), shells) )

    #Manually Appending dummy shells
    shells = shells + ['/usr/sbin/nologin', '/bin/false']

    return command_success( data=shells )
\end{lstlisting}
Alcuni delle funzioni del modulo di nomodo \texttt{user} richiedono che gli sia passata il percorso di una shell
come parametro. Per portare al minimo gli errori si è creata questa funzione che non fa altro che restituire
la lista delle shell installate nel sistema, in modo che l'utente non debba immettere manualmente la shell
ma deve selezionarla da una lista. Un esempio è quando si chiama la funzione \texttt{updateusershell}.
Evitiamo così sia errori volontari che errori di scrittura.
\paragraph{Parametri}
La funzione nella sua semplicità non prende parametri.
\paragraph{Funzionamento}
\begin{itemize}
	\item{Apre il file che contiene le shell \texttt{/etc/shells} in lettura, ne legge il contenuto,
		lo divide per linee creando una lista e inserisce tale lista nella variabile \texttt{shells}}
	\item{In una funzione \texttt{filter} legge le righe una alla volta e se una riga inizia per \string# (cancelletto)
		la rimuove dalla lista. La verifica è effettuata tramite la funzione \texttt{startswith} che
		restituisce \texttt{True} se una stringa inizia col carattere passato come argomento}
	\item{Nella terza parte del codice allla lista delle shells aggiunge le shell dummy utilizzate
		per impedire l'accesso con l'utente che ha quella shell assegnata. Queste shell vengono
		usate per utenti di servizio, come l'utente \texttt{www-data}}
	\item{Restituisce le shell nella solita funzione di successo \texttt{command\_success}}
\end{itemize}
\paragraph{Return}
Restituisce una lista dove ogni elemento è il percorso di una delle shell installate nel sistema.

\subsubsection{updateusershell}\label{updateusershell}
\begin{lstlisting}
def updateusershell(user, shell):
	
    logid = mongolog( locals() )
    
    if not shell:
        return command_error( returncode=200, stderr="La stringa contenente il nome della shell non puo' essere vuota")


    command = ['chsh', user, '-s', shell]
    
    try:
        check_call(command)
    except CalledProcessError as e:
        return command_error( e, command, logid )

    
    return command_success( logid=logid )
\end{lstlisting}
La funzione nasce per aggiornare la shell assegnata ad un utente. \paragraph{Parametri}
\begin{itemize}
	\item{\texttt{user}: è lo username dell'utente a cui verrà cambiata la shell}
	\item{\texttt{shell}: è la nuova shell da assegnare all'utente. La lista delle shell che si possono utilizzare
		può essere ricavata dalla funzione \nameref{getshells}}
\end{itemize}
\paragraph{Funzionamento}
\begin{lstlisting}
    logid = mongolog( locals() )
    
    if not shell:
        return command_error( returncode=200, stderr="La stringa contenente il nome della shell non puo' essere vuota")
\end{lstlisting}
L'operazione risulta \textit{sensibile}, viene quindi prima di tutto memorizzato un mongolog con le informazioni
sull'operazione.\\
Viene poi controllato che il parametro \texttt{shell} non sia una stringa vuota, per evitare errori con la bash.
\begin{lstlisting}
    command = ['chsh', user, '-s', shell]
    
    try:
        check_call(command)
    except CalledProcessError as e:
        return command_error( e, command, logid )

    
    return command_success( logid=logid )
\end{lstlisting}
Viene poi lanciato il comando \texttt{chsh} specificando nome utente e shell usando \texttt{check\_call} e verificando
che non sia generata una eccezione. Dopo il cambio delle shell se l'operazione è andata a buon fine quindi si chiama
la funzione di successo \texttt{command\_success} passandogli l'object id del mongolog.
\paragraph{Return}
Restituisce il dizionario di successo con la variabile \texttt{Data} a \texttt{None} e \texttt{logid} contenente
l'object id del log su mongo contenente le informazioni sull'operazione appena effettuata.

\subsubsection{adduser}\label{adduser}
\begin{lstlisting}
def adduser(user, password, shell="/bin/bash"):
	
    logid = mongolog( locals() )
    
    if not shell:
    	return command_error( returncode=200, stderr="La stringa contenente il nome della shell non puo' essere vuota" )
    
    try:
        command = ['useradd', '-m', '-p', password, '-s', shell, user]
        check_output(command, stderr=PIPE, universal_newlines=True)
    except CalledProcessError as e:
        return command_error( e, command, logid )
    

    return command_success( logid=logid )
\end{lstlisting}
Serve ad aggiungere nuovi utenti al sistema.
\paragraph{Parametri}
\begin{itemize}
	\item{\texttt{user}: è il nome utente del nuovo utente che si sta creando. Deve essere univoco nel sistema}
	\item{\texttt{password}: la password di accesso del nuovo utente}
	\item{\texttt{shell="/bin/bash"}: è la shell che verrà assegnata all'utente all'atto di creazione.
		Se questo parametro non viene passato viene assegnata la shell di default di sistema che è \texttt{bash}}
\end{itemize}
\paragraph{Funzionamento}
\begin{lstlisting}
    logid = mongolog( locals() )
    
    if not shell:
    	return command_error( returncode=200, stderr="La stringa contenente il nome della shell non puo' essere vuota" )
\end{lstlisting}
Viene creato un mongolog in quanto operazione sensibile che va a modificare il sistema e potrebbe compromettere
la sicurezza dello stesso. Come in \ref{updateusershell} viene verificato che il parametro \texttt{shell} non sia
una stringa vuota per evitare errori con la bash.
\begin{lstlisting}
    try:
        command = ['useradd', '-m', '-p', password, '-s', shell, user]
        check_output(command, stderr=PIPE, universal_newlines=True)
    except CalledProcessError as e:
        return command_error( e, command, logid )
    

    return command_success( logid=logid )
\end{lstlisting}
Viene poi composto il comando \texttt{useradd} definendo tutte le specifiche dell'utente ed indicando di creare
una home col parametro \texttt{-m}, viene eseguito e viene controllato che non venga lanciata nessuna eccezione.\\
Se tutto va a buon fine viene invocata la funzione di successo \texttt{command\_success} passandogli l'object id
del documento mongo creato contenente le informazioni sull'operazione di creazione dell'utente.
\paragraph{Return}
Restituisce il dizionario di successo generato da \texttt{command\_success} con la chiave \texttt{Data} a \texttt{None}
e la chiave \texttt{logid} contenente l'object id del documento creato e contenente le informazioni sull'operazione
eseguita.

\subsubsection{removeuser}\label{removeuser}
\begin{lstlisting}
def removeuser(user, removehome=False):
	
    userinfo = getuser(user)
    if userinfo['returncode'] is 0:
        userinfo = userinfo['data']
    else:
        return userinfo

    logid = mongolog( locals(), userinfo )
    

    try:
        command = ['deluser', user]
        if removehome: command.append('--remove-home') 

        check_output( command, stderr=PIPE, universal_newlines=True )
    except CalledProcessError as e:
        return command_error( e, command, logid )
    
    
    return command_success( logid=logid )
\end{lstlisting}
È la funzione opposta a \nameref{adduser} e serve a rimuovere un utente dal sistema.
\paragraph{Parametri}
\begin{itemize}
	\item{\texttt{user}: è il nome utente dell'utente da eliminare dal sistema}
	\item{\texttt{removehome=False}: se \texttt{True} indica di rimuovere anche la home dell'utente oltre
		all'utente stesso. Di default è \texttt{False} in quanto la home degli utenti potrebbero contenere
		dati importanti che non si vuole perdere}
\end{itemize}
\paragraph{Funzionamento}
\begin{lstlisting}
    userinfo = getuser(user)
    if userinfo['returncode'] is 0:
        userinfo = userinfo['data']
    else:
        return userinfo

    logid = mongolog( locals(), userinfo )
\end{lstlisting}
La rimozione di un utente è una operazione molto importante, viene quindi generato un mongolog contenente,
oltre ai parametri con cui è chiamata la funzione, anche le informazioni sull'utente che sta per essere rimosso,
ricavate invocando la funzione \texttt{getuser()}.
\begin{lstlisting}
    try:
        command = ['deluser', user]
        if removehome: command.append('--remove-home') 

        check_output( command, stderr=PIPE, universal_newlines=True )
    except CalledProcessError as e:
        return command_error( e, command, logid )
    
    
    return command_success( logid=logid )
\end{lstlisting}
All'atto del lancio del comando \texttt{deluser} viene quindi verificato il parametro \texttt{removehome};
se questo risulta essere \texttt{True} viene aggiunto al comando \texttt{deluser <user>} anche il parametro
\texttt{--remove-home} istruendo quindi lo stesso a rimuovere anche la cartella \texttt{/home/<user>/}.\\
Viene controllato quindi che non venga generata l'eccezione \texttt{CalledProcessError} e se tutto va a buon fine
viene invocata la funzione di successo \texttt{command\_success} passandogli l'object id del documento mongo
che tiene traccia delle informazioni dell'operazione.
\paragraph{Return}
Restituisce il dizionario di successo generato da \texttt{command\_success} con la key \texttt{Data} a \texttt{None}
e la key \texttt{logid} contenente l'object id del documento mongo creato e che tiene traccia delle informazioni
sull'operazione.


\subsection{Network}\label{network}
La sezione network raccoglie tutte le funzioni utili per la gestione della rete, quali creazione e distruzione
di interfacce, cambio indirizzo, settaggio rotte ecc.
\subsubsection{ifacestat}\label{ifacestat}
\begin{lstlisting}
def ifacestat(iface="", namesonly=False):

    command = ['ifconfig', '-a']
    if iface: command.append(iface)

    try:
        output = check_output(command, stderr=PIPE, universal_newlines=True)
    except CalledProcessError as e:
        return command_error( e, command )


    output = output.split('\n\n')
    del output[-1]


    ifaces = list() if namesonly else dict()
    for iface in output:

        iface = iface.splitlines()
        firstline = iface.pop(0).split(None, maxsplit=1)


        if namesonly:
            ifaces.append( firstline[0] )
        else:
            iface.insert(0, firstline[1])

            i = 0
            for index, value in enumerate(iface):
                i += 1
                iface[index] = iface[index].strip()
                if iface[index].startswith('UP') or iface[index].startswith('DOWN'):  break

            ifaces.update({ firstline[0]: iface[:i] })

    return command_success( data=ifaces )
\end{lstlisting}
La funzione serve ad ottenere uno sommario sullo stato delle interfacce di rete attualmente installate su sistema.
\paragraph{Parametri}
\begin{itemize}
	\item{\texttt{iface=""}: Se non nullo (come di defaut) questo parametro serve a farsi restituire dalla funzione
		lo stato della sola interfaccia indicata. Questa variabile deve contenere il nome esatto dell'interfaccia
		di cui si vogliono le informazioni (es. "ens1")}
	\item{\texttt{namesonly=False}: se a \texttt{True} restituisce i soli nomi dell'interfaccia
		invece di tutte le informazioni}
\end{itemize}
\paragraph{Funzionamento}
\begin{lstlisting}
    command = ['ifconfig', '-a']
    if iface: command.append(iface)

    try:
        output = check_output(command, stderr=PIPE, universal_newlines=True)
    except CalledProcessError as e:
        return command_error( e, command )
\end{lstlisting}
Il comando che restituisce l'output più adatto è \texttt{ifconfig}, viene quindi lanciato usando \texttt{check\_call()}
e l'output conservato nella variabile \texttt{output}.
Notare che ad \texttt{ifconfig} si è aggiunto il parametro \texttt{-a} in quanto vogliamo ottenere le informazioni
su tutte le interfacce e non solo sulle interfacce attualemente abilitate.
Se il parametro \texttt{iface} è non nullo questa stringa viene aggiunta al comando così da ottenere solo le info
di questa interfaccia.\footnote{\label{ifconfignoproblem}Anche se \texttt{iface} è settato non viene comunque rimosso
il parametro \texttt{-a} in quanto non interferisce con la buona esecuzione del comando}
\begin{lstlisting}
    output = output.split('\n\n')
    del output[-1]

    ifaces = list() if namesonly else dict()
\end{lstlisting}
\texttt{ifconfig} divide le informazioni sulle interfacce con una linea vuota e la fine dell'output con due linee vuote.
Dividiamo quindi l'output splittando per \texttt{"\textbackslash n\textbackslash n"} ottenendo una lista di N+1 stringhe
dove N è il numero delle interfacce del sistema e 1 è la stringa vuota che eliminiamo lanciando il secondo comando (\texttt{del}).\\
Viene poi creata la variabile \texttt{ifaces} che conterrà le informazioni da restituire all'utente.
Se il parametro \texttt{namesonly} è settato a \texttt{True} viene inizializzata come lista (una lista di nomi),
come dizionario altrimenti.
\begin{lstlisting}
    for iface in output:

        iface = iface.splitlines()
        firstline = iface.pop(0).split(None, maxsplit=1)

        if namesonly:
            ifaces.append( firstline[0] )
        else:
            iface.insert(0, firstline[1])
            i = 0
            for index, value in enumerate(iface):
                i += 1
                iface[index] = iface[index].strip()
                if iface[index].startswith('UP') or iface[index].startswith('DOWN'):  break

	ifaces.update({ firstline[0]: iface[:i] })

    return command_success( data=ifaces )
\end{lstlisting}
Andiamo quindi ad iterare su queste interfacce che abbiamo ricavato.
Per ogni intrefaccia ricavata:
\begin{itemize}
	\item{Si dividono le informazioni sulle interfacce per riga (splitlines())}
	\item{La prima riga contiene il nome dell'interfaccia più alcune informazioni divisi da uno spazio (il primo spazio della riga);
		si va quindi a rimovere questa riga (pop(0)), e la si divide per il primo spazio ottenendo \texttt{firstline}
		che è una lista dove il primo elemento è il nome dell'interfaccia mentre il secondo è la prima riga
		di informazioni}
	\item{Se \texttt{namesonly} è \texttt{True} si vogliono solo i nomi delle interfacce e si inserisce in \texttt{ifaces}
		(usata come lista) il nome dell'interfaccia contenuta in \texttt{firstline[0]} per poi passare alla prossima iterazione}
	\item{Se invece \texttt{namesonly} è \texttt{False}, \texttt{ifaces} è un dizionario. Questo dizionario verrà creato in modo
		che la chiave sia il nome dell'interfaccia mentre il valore siano le sue informazioni.
		Andiamo quindi prima di tutto ad inserire la prima riga di informazioni (contenuta in \texttt{firstline[1]}
		nella variabile \texttt{iface} in modo che questa variabile contenga  nuovamente la lista completa delle informazioni
		sull'interfaccia}
	\item{L'output di \texttt{ifconfig} porta con se delle informazioni che attualmente a noi non servono.
		Per eliminare queste informazioni che risiedono nelle ultime righe della variabile \texttt{iface} si esesegue questo secondo ciclo for.
		Il ciclo viene eseguito usando \texttt{enumerate} in quanto abbiamo bisogno di modificare la variabile \texttt{iface} originale
		e non una sua copia, per motivi in seguito spiegati.\\
		Si costituisce un indice \texttt{i} che indica la riga su cui stiamo iterando e:
		\begin{itemize}
			\item{Viene incrementato l'indice che identifica la riga sulla quale si sta iterando}
			\item{Vengono rimossi gli spazi iniziali e finali della riga. Da qui l'uso di \texttt{enumerate}}
			\item{Se la riga inizia per \textit{UP} oppure \textit{DOWN} allora abbiamo raggiunto l'ultima riga che contiene informazioni
				a noi utili. Si lancia quindi un break uscendo dal ciclo; la varibile \texttt{i} a questo punto
				contiene l'esatta riga dove fermarsi  e potrà essere sfruttata per tagliare le righe che non ci servono}
		\end{itemize}}
	\item{Usciti dal ciclo non ci resta che tagliare le righe che non ci servono ed inserire nel dizionario \texttt{ifaces}
		la chiave e il valore. Viene quindi lanciato \texttt{ifacea.update()} dove si passa come chiave \texttt{firstline[0]} che è il nome
		dell'interfaccia e come valore \texttt{iface[:i]} che solo le informazioni sulla stessa tagliate fino alla riga \texttt{i}}
\end{itemize}
Alla fine del parsing, come solito per le funzioni di nomodo, viene chiamata la funzione di successo \texttt{command\_success}
passandogli nel parametro \texttt{data} il dizionario appena creato \texttt{ifaces}.
\paragraph{Return}
\begin{itemize}
	\item{Se \texttt{namesonly} è \texttt{True} restituisce una lista di stringhe dove ogni stringa è il nome di una intrefaccia
		presente nel sistema}
	\item{Se \texttt{namesonly} è \texttt{False} restituisce un dizionario dove la chiave è il nome delle interfacce di sistema
		mentre il valore sono le informazioni sulla stessa, come ad esempio indirizzo IPv4 e IPv6, MAC address, stato ecc.}
\end{itemize}

\subsubsection{getnewifacealiasname}\label{getnewifacealiasname}
\begin{lstlisting}
def getnewifacealiasname(iface):
    
    ifaces = ifacestat( namesonly=True )
    if ifaces['returncode'] is 0:
        ifaces = ifaces['data']

    
    aliasid = 0
    for item in ifaces:
        if item.startswith( iface + ':' ):
            item = int(re.sub('.*:', '', item))
            if aliasid is item: aliasid += 1
            else: break

    return command_success( data = iface + ':' + str(aliasid) )
\end{lstlisting}
Questa funzione non fa altro che restituire al chiamante il possibile nome di una nuova interfaccia alias
data un'interfaccia fisica esistente. È intesa per essere usata come titolo della pagina in cui l'utente
andrà ad inserire le specifiche della nuova interfaccia e per essere passata alla funzione \nameref{createalias}
per la creazione dell'interfaccia virtuale.
\paragraph{Parametri}
Prende un solo parametro \texttt{iface} che è l'interfaccia a cui fare riferimento per la creazione del nuovo alias.
\paragraph{Funzionamento}
La funzione si basa su queste 3 considerazioni:
\begin{enumerate}
	\item{Il nome di una interfaccia alias è costitita dal nome dell'interfaccia più un due punti più
		un identificativo numerico per l'alias stesso che parta da 0}
	\item{Data una interfaccia, ad es. \texttt{ens1}, se per questa interfaccia sono già presenti degli alias, ad es.
		\texttt{ens1:1} e \texttt{ens1:2}, deve essere restituito all'utente il nome alias \texttt{ens1:3}}
	\item{Per evitare un numero sempre crescente per i nomi alias un nuovo nome dovrà riempire
		il buco lasciato da un interfaccia che sia stata eliminata. Ad es. se abbiamo \texttt{ens1:0} e \texttt{ens1:2}
		la nuova interfaccia dovrà avere il nome \texttt{ens1:1}}
\end{enumerate}
Si discutono i metodi utilizzati per soddisfare tali principi.
\begin{lstlisting}
    ifaces = ifacestat( namesonly=True )
    if ifaces['returncode'] is 0:
        ifaces = ifaces['data']
\end{lstlisting}
Viene chiamata la funzione \nameref{ifacestat} con il parametro \texttt{namesonly} impostato a \texttt{True}
così da ottenere i nomi di tutte le interfacce del sistema; viene inoltre fatto un controllo
sul codice di ritorno della funzione.
\begin{lstlisting}
    aliasid = 0
    for item in ifaces:
        if item.startswith( iface + ':' ):
            item = int(re.sub('.*:', '', item))
            if aliasid is item: aliasid += 1
            else: break

    return command_success( data = iface + ':' + str(aliasid) )
\end{lstlisting}
Si inizializza quindi una variabile \texttt{aliasid} al primo numero possibile per gli identificativi alias,
cioè 0 (ad esempio \texttt{ens1:0}).\\
Per capire quanto a seguire bisogna tenere in mente che l'output di ifconfig ordina gli alias di
un'interfaccia; ad esempio con \texttt{ens1} l'ordine sarà \texttt{ens1, ens1:0, ens1:2}
e mai ad esempio \texttt{ens1, ens1:2, ens1:0}\\
Con tale considerazione si inizia iterando sui nomi delle interfacce. Se questa è un alias dell'interfaccia
passata come parametro, cioè se il suo nome inizia (\texttt{startswith}) con il nome dell'interfaccia \texttt{iface}
seguita dal due punti si entra nell'if che si vede in codice. In questo \texttt{if}
si elimina il nome dell'interfaccia ed i due punti utilizzand la libreria \texttt{re}
(ad esempio  \texttt{ens0:1} diventa semplicemente 1), ottenendo
il numero identificativo della prima interfaccia alias; si confronta quindi questo numero con \texttt{aliasid}.
Se questi sono uguali l'interfaccia alias con identificativo \texttt{aliasid} è sicuramente occupata,
quindi si itera e si tenta nuovamente con il prossimo alias; se invece \texttt{aliasid} non coincide
col numero identificativo del primo alias allora il posto è libero e si esce dal ciclo con un break.\\
Dopodichè basta chiamare la funzione di successo \texttt{command\_success} passandogli nel campo \texttt{data}
il nome della nuova interfaccia, che non è altro che il nome della stessa seguita dal 2 punti e dal numero identificativo
dell'alias contenuto nella variabile \texttt{aliasid}.
\paragraph{Return}
Restituisce il nome del nuovo alias dell'interfaccia \texttt{iface} da utilizzare come titolo della pagina in cui l’utente
andrà ad inserire le specifiche della nuova interfaccia o per essere passata alla funzione \nameref{createalias} per
la creazione dell’interfaccia virtuale.

\subsubsection{ifacedown}\label{ifacedown}
\begin{lstlisting}
def ifacedown( iface ):
    
    logid = mongolog( locals() )

    command = ['ifconfig', iface, 'down']

    try:
        check_call(command)
    except CalledProcessError as e:
        return command_error( e, command, logid )

    return command_success( logid=logid )
\end{lstlisting}
La funzione è intesa per disattivare un'interfaccia di rete.
\paragraph{Parametri}
Prender un solo parametro che è l'interfaccia di rete da disattivare.
\paragraph{Funzionamento}
Essendo un'operazione sensibile prima di tutto crea un mongolog e ne memorizza l'object id nella variabile \texttt{logid}.\\
Poi semplicemente costruisce il comando in questo modo: \texttt{ifconfig <nome\_interfaccia> down} e lo lancia usando 
\texttt{check\_call} (in quanto non è restituiuto output) e verifica che non siano avvenute eccezioni. Chiama all fine
la funzione di successo \texttt{command\_success} passandoli nel campo \texttt{logid} l'object id del documento mongo
creato e contenenti le specifiche dell'operazione appena eseguita.
\paragraph{Return}
Restituisce il dizionario di successo con il campo \texttt{data} a \texttt{None} e il campo \texttt{logid} contenente
l'object id del documento mongo che contiene le specifiche dell'operazione eseguita.

\subsubsection{ifaceup}\label{ifaceup}
\begin{lstlisting}
def ifaceup( iface, address="", netmask="", broadcast="" ):
    
    logid = mongolog( locals() )    

    command = ['ifconfig', iface]
    if address: command.append(address)
    if netmask: command = command + ['netmask', netmask]
    if broadcast: command = command + ['broadcast', broadcast]
    command.append('up')

    try:
        check_output = check_call(command, stderr=PIPE, universal_newlines=True)
    except CalledProcessError as e:
        return command_error( e, command, logid )

    return command_success( logid=logid )
\end{lstlisting}
È l'opposto della funzione \nameref{ifacedown} e serve ad abilitare un'intrefaccia di rete attualmente disabilitata.
\paragraph{Parametri}
Prende 4 parametri:
\begin{itemize}
	\item{\texttt{iface}: il nome dell'interfaccia da tirare sù}
	\item{\texttt{address=""}: è l'indirizzo da assegnare all'interfaccia. Non è obbligatorio in quanto l'interfaccia
		potrebbe già avere un indirizzo assegnato}
	\item{\texttt{netmask=""}: è la maschera di rete da assegnare all'interfaccia. Non è obbligatorio in quanto l'interfaccia
		potrebbe già avere una maschera di rete settata}
	\item{\texttt{broadcast=""}: è l'indirizzo facente parte della stessa rete dell'interfaccia, sulla quale i pacchetti
		vengono inviati in broadcast a tutti gli host della rete stessa. Non è obbligatorio in quanto l'interfaccia
		potrebbe già avere un indirizzo broadcast settata}
\end{itemize}
\paragraph{Funzionamento}
Si memorizza prima di tutto un mongolog per tenere traccia dell'operazione.\\
Durante la fase di costruzione del comando semplicemente di controlla ad uno ad uno se è stato assegnato un valore ai parametri;
in tale caso si appende al comando da lanciare. Uno volta controllati tutti i parametri si appende la parola \texttt{up}
(che indica che l'interfaccia va abilitata) e si lancia il comando in una \texttt{check\_call} (nessun output generato)
controllando che non si sia verificata un'eccezione.\\
Se tutto è andato a buon fine si chiama la funzione di successo \texttt{command\_success} passandogli l'object id
del documento mongo creato.
\paragraph{Return}
Il dizionario di successo della funzione \texttt{command\_success} col campo \texttt{data} a \texttt{None} e il campo
\texttt{logid} contenente l'object id del documento mongo creato e contenente le specifiche dell'operazione appena effettuata.

\subsubsection{createalias}\label{createalias}
\begin{lstlisting}
def createalias( aliasname, address, netmask="", broadcast="" ):

    iface = re.sub(':.*', '', aliasname)

    aliases = ifacestat( namesonly=True )
    if aliases['returncode'] is 0:
        if not iface in aliases['data']:
            return command_error( returncode=197, stderr="No interface found with such name: " + iface )
    else:
        return aliases

    return ifaceup( iface=aliasname, address=address, netmask=netmask, broadcast=broadcast )
\end{lstlisting}
Nasce per consentire la creazione di una interfaccia alias dal pannello web di nomodo.
Utilizza la funzione \nameref{ifaceup}.
\paragraph{Parametri}
Accetta gli stessi parametri di \texttt{ifaceup}, che sono i seguenti:
\begin{itemize}
	\item{\texttt{aliasname}: È  il nome della nuova interfaccia alias da creare. Può essere ricavata usando
		la funzione \nameref{getnewifacealiasname}}
	\item{\texttt{address}: L'indirizzo della nuova interfaccia. È l'unico parametro obbligatorio
		insieme al nome dell'alias}
	\item{\texttt{netmask=""}: La maschera di rete per la nuova interfaccia. Non è obbligatorio e se
		non passato viene calcolata dal sistema}
	\item{\texttt{broadcast=""}: L'indirizzo di broadcast su cui l'interfaccia invia i pacchetti destinati
		a tutti gli host della rete. Non è obbligatorio e se non passato viene calcolato dal sistema}
\end{itemize}
\paragraph{Funzionamento}
Il nome dell'interfaccia da creare può essere ottenuto chiamando la funzione \nameref{getnewifacealiasname}
ma è comunque data la possibilità all'utente di scegliere un nome personalizzato. A causa di ciò a differenza
delle altre funzioni in \texttt{createalias} bisogna verificare almeno se l'interfaccia di cui si vuole
creare l'alias esiste.\\
Viene quindi estratta dal parametro \texttt{aliasname} il nome dell'interfaccia principale, eliminando
il due punti e l'identificativo dell'alias, usando la libreria per le espressioni regolari \texttt{re}.
Ad esempio se \texttt{aliasname} è \texttt{ens1:0} si elimina \texttt{:0} ottenendo \texttt{ens1}.\\
Dopodichè si chiama la funzione \nameref{ifacestat} col parametro \texttt{namesonly} settato a \texttt{True}
per ottenere i nomi di tutte le interfacce del sistema.\\
Viene ovviamente verificato che le operazioni della funzione chiamata non abbiano generato errori verificare
la chiave \texttt{returncode} del dizionario ottenuto da tale funzione; se \texttt{returncode} è diverso
da 0 viene restituito il dizionario di errore così come è stato ottenuto al chiamante.
Se invece l'operazione è andata a buon fine si verifica che l'interfaccia ottenuta dal precedente \texttt{re.sub}
sia presente nella lista di interfacce del sistema. Se non presenta viene generato un errore personalizzato
chiamando la funzione \texttt{command\_error}, mentre se presente semplicemente viene chiamata la funzione
precedentemente discussa \nameref{ifaceup} che passandogli paripari i parametri inseriti dalll'utente.
Con la sua sintassi questa funzione riesce anche a creare una interfaccia alias.
\paragraph{Return}
Restistuisce il dizionario di ritorno generato dalla funzione \nameref{ifaceup}.

\subsubsection{destroyalias}\label{destroyalias}
\begin{lstlisting}
def destroyalias( aliasname ):
    return ifacedown( aliasname )
\end{lstlisting}
È l'inverso della funzione \nameref{createalias} e serve per rimuovere una interfaccia alias dal sistema.
\paragraph{Parametri}
Accetta un solo parametro \texttt{aliasname} che è il nome dell'interfaccia alias da distruggere.
\paragraph{Funzionamento}
A differenza della funzione \nameref{createalias} qui non c'è bisogno di verificare se l'interfaccia
esista in quanto all'utente non è data la possibilità di definire una interfaccia alias personalizzata
da distruggere ma semmplicemente ne sceglie una da una lista di intrefacce presenti nel sistema.\\
Viene quindi semplicemente chiamata la funzione \nameref{ifacedown} passandogli il nome dell'interfaccia.
\paragraph{Return}
Restituisce il dizionario di ritorno generato dalla funzione \nameref{ifacedown}.

\subsubsection{editiface}\label{editiface}
\begin{lstlisting}
def editiface( iface, address="", netmask="", broadcast="" ):
    return ifaceup( iface=iface, address=address, netmask=netmask, broadcast=broadcast ) 
\end{lstlisting}
La funzione consente di modificare dei parametri dell'interfaccia, quali indirizzo,
maschera di rete e indirizzo di broadcast.
\paragraph{Parametri}
Prende fino a 4 parametri:
\begin{itemize}
	\item{\texttt{iface}: è il nome dell'interfaccia da modificare}
	\item{\texttt{address=""}: non è obbligatorio e se passato indica il nuovo indirizzo che
		l'interfaccia \texttt{iface} deve avere}
	\item{\texttt{netmask=""}: non è obbligatorio e se passato indica la nuova maschera di rete
		che l'interfaccia \texttt{iface} deve avere}
	\item{\texttt{broadcast=""}: non è obbligatorio e se passato indica il nuovo indirizzo di broadcast
		che l'interfaccia \texttt{iface} deve avere}
\end{itemize}
\paragraph{Funzionamento}
Non è obbligatorio verificare se l'interfaccia \texttt{iface} è presente nel sistema (così come fa
\nameref{createalias}) in quanto l'utente non ha la possibilità di specificare a mano l'interfaccia
da modificare ma semplicemente la sceglie da una lista.\\
Semplicemenete chiama la funzione \nameref{ifaceup} passandogli tutti i parametri che ha ricevuto;
a causa della sua sintassi generica questa funzione consente anche la modifica di interfacce.
\paragraph{Return}
Restituisce il dizionario di ritorno generato dalla funzione \nameref{ifaceup}.

\subsubsection{getroutes}\label{getroutes}
\begin{lstlisting}
def getroutes():
    
    command = ['route', '-n']

    try:
        output = check_output(command, stderr=PIPE, universal_newlines=True).splitlines()
    except CalledProcessError as e:
        return command_error( e, command )


    output.pop(0)
    header = output.pop(0).split()
    routes = list( map( lambda route: dict(zip(header, route.split())), output ) )


    return command_success( data=routes )
\end{lstlisting}
La funzione serve ad ottenere la lista di tutte le rotte utilizzate dal sistema per uscire sulla rete.
\paragraph{Parametri}
Non prende parametri.
\paragraph{Funzionamento}
\begin{lstlisting}
    command = ['route', '-n']

    try:
        output = check_output(command, stderr=PIPE, universal_newlines=True).splitlines()
    except CalledProcessError as e:
        return command_error( e, command )
\end{lstlisting}
Nella prima parte del codice viene costruito il comando da lanciare per ottenere le rotte.
Si è usato il comando \texttt{route} passandogli il parametro \texttt{-n} in modo da ottenere
la lista delle rotte senza che gli indirizzi di rete vengano risolti.\\
Una voilta costruito il comando viene lanciato usando la funzione \texttt{check\_output} che
oltre ad eseguirlo restituisce anche l'output dello stesso. In caso venga generata l'eccezione
\texttt{CalledProcessError} questa viene catturata e passata al comando \nameref{command\string_error}
che crea un dizionario di errore che viene restituito all'utente.
\begin{lstlisting}
    output.pop(0)
    header = output.pop(0).split()
    routes = list( map( lambda route: dict(zip(header, route.split())), output ) )

    return command_success( data=routes )
\end{lstlisting}
Nella seconda parte prima di tutto viene eliminato la prima riga del comando che solitamente contiene
la stringa \textit{Kernel IP routing table} (a noi non utile) usando la funzione \texttt{pop()}.\\
Viene poi rimosso dall'output e splittato l'header; questo header contiene la descrizione breve
dei campi della tabella di routing, e solitamente è il seguente:
\begin{lstlisting}
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
\end{lstlisting}
Nell'ultima parte usando la funzione \texttt{map()} viene creata una lista di dizionari
in cui:
\begin{itemize}
	\item{Ogni elemento delle lista contiene un dizionario con le specifiche di una rotta}
	\item{Ogni dizionario ha tanti campi quanti ne ha l'header, e ogni campo contine
		come chiave un elemento dell'header e come valore il valore della rotta inerente
		a quell'elemento header}
\end{itemize}
Un esempio vale più di mille parole, quindi ecco un esempio del dizionario generato su un sistema
Ubuntu Server 16.04 che gira su un container LXD:
\begin{lstlisting}
[{'Destination': '0.0.0.0',
  'Flags': 'UG',
  'Gateway': '10.100.10.1',
  'Genmask': '0.0.0.0',
  'Iface': 'eth0',
  'Metric': '0',
  'Ref': '0',
  'Use': '0'},
{'Destination': '10.0.0.0',
  'Flags': 'U',
  'Gateway': '0.0.0.0',
  'Genmask': '255.0.0.0',
  'Iface': 'eth0',
  'Metric': '0',
  'Ref': '0',
  'Use': '0'},
{'Destination': '10.100.10.0',
  'Flags': 'U',
  'Gateway': '0.0.0.0',
  'Genmask': '255.255.255.0',
  'Iface': 'eth0',
  'Metric': '0',
  'Ref': '0',
  'Use': '0'}]
\end{lstlisting}
Alla fine viene chiamata la funzione di successo \texttt{command\_success} passandogli il dizionario
delle rotte nel campo data.
\paragraph{Return}
Restituisce il dizionario di successo, con il campo \texttt{data} contenente il dizionario delle rotte
descritto nel paragrafo \textbf{funzionamento}.

\subsubsection{addroute}\label{addroute}
\begin{lstlisting}
def addroute(gw, net, netmask, default=False):

    logid = mongolog( locals() )

    command = ['route', 'add']
    if default:
        command = command + ['default', 'gw', gw]
    elif net is None or netmask is None:
        command_error( returncode=201, stderr='On non-default route you must enter "net" and "netmask" parameters' )
    else:
        command = command + ['-net', net, 'netmask', netmask, 'gw', gw]

    try:
        check_call(command)
    except CalledProcessError as e:
        return command_error( e, command, logid )

    return command_success( logid=logid )
\end{lstlisting}
La funzione nasce per aggiungere una rotta alle rotte già presenti nel sistema, visualizzabili chiamando
la funzione \nameref{getroutes}.
\paragraph{Parametri}
Accetta 4 parametri di cui la maggior parte obbligatori:
\begin{itemize}
	\item{\texttt{gw}: è l'indirizzo su cui uscire sulla rete \texttt{net}}
	\item{\texttt{net}: rappresenta la rete a di destinazione a cui la rotta fa riferimento}
	\item{\texttt{netmask}: è la maschera di rete della rete di destinazione, identificata dal parametro \texttt{net}}
	\item{\texttt{default=False}: se \texttt{True} indica di creare un default gateway} 
\end{itemize}
\paragraph{Funzionamento}
La maggior parte della funzione si basa sulla costruzione del comando. Le prime due keyword sono predenfinite
e sono \texttt{route add} che indicano la creazione di una nuova rotta. Entrando nell'\texttt{if} distinguiamo
tre situazioni:
\begin{itemize}
	\item{Il parametro \texttt{default} è \texttt{True}: si vuole creare un default gateway, si ha quindi solo
		bisogno del gateway identificato dal parametro \texttt{gw}. Il comando viene costruito inserendo
		questo unico parametro}
	\item{\texttt{default} è \texttt{False} ma i parametri sono \texttt{None} o stringhe vuote: c'è stato un
		errore nella chiamata, se \texttt{default} è \texttt{False} per costruire la rotta c'è bisogno
		di tutti e tre i parametri \texttt{gw}, \texttt{net} e \texttt{netmask}}
	\item{\texttt{default} è \texttt{False} e si hanno tutti i parametri: si vuole creare una nuova rotta,
		e il comando viene costruito inserendo tutti questi parametri}
\end{itemize}
Dopo la costruzione del comando lo si lancia usando la \texttt{check\_call} (in quanto non viene restituito
output) e si chiama la funzione di errore o di successo a secondo del risultato.
Alla funzione di successo viene passato l'object id del documento mongo creato.
\paragraph{Return}
Restituisce il dizionario di successo con la chiave \texttt{data} a \texttt{None} (nessun output restituito)
e la chiave \texttt{logid} contenente l'object id del mongolog creato contenente le informazioni
sull'operazione eseguita.

\subsubsection{defaultroute}\label{defaultroute}
\begin{lstlisting}
def defaultroute(gw): return addroute(gw, net=None, netmask=None, default=True) 
\end{lstlisting}
La funzione è definita come \textit{Funzione alias} in quanto basata quasi completamente su un'altar funzione.
Prende in carico di creare un default gateway chiamando la funzione \nameref{addroute} con i giusti parametri.
\paragraph{Parametri}
Prende un solo parametro che è il gateway da assegnare.
\paragraph{Funzionamento}
Semplicemente chiamta la funzione \nameref{addroute} passandogli il gateway nel parametro \texttt{gw}, settando
la variabile \texttt{default} a \texttt{True} e le altre variabili a \texttt{None}.
\paragraph{Return}
Restituisce il dizionario di ritorno della funzione \nameref{addroute}.

\subsubsection{delroute}\label{delroute}
\begin{lstlisting}
def delroute(route):

    logid = mongolog( locals() )

    if not type(route) is type(dict()):
        command_error( returncode=202, stderr='delroute function can only accept a dictionary as argument' )

    command = [ 'route', 'del', '-net', route['Destination'], 'netmask', route['Genmask'], 'gw', route['Gateway'] ]

    try:
        check_call(command)
    except CalledProcessError as e:
        return command_error( e, command, logid )

    return command_success( logid=logid )
\end{lstlisting}
La funzione nasce per cancellare una delle rotte presenti nel sistema.\\
ATTENZIONE: leggere attentamente il paragrafo \textit{Prametri} prima di utilizzarla, in quanto è l'unica
che si comporta direttamente sulla questione "parametri in ingresso".
\paragraph{Parametri}
Accetta un solo parametro che è un dizionario contenente le specifiche della rotta da eliminare. Questo dizionario deve
essere lo stesso che si ottiene chiamando la funzione \nameref{getroutes}. Ad esempio prendendo come riferimento l'esempio
in sezione \ref{getroutes} al paragrafo \textit{Funzionamento} volendo cancellare l'ultima rotta dovrei prendere il seguente
dizionario (che è il terzo) e passarlo per intero al questa funzione:
\begin{lstlisting}
{'Destination': '10.100.10.0',
  'Flags': 'U',
  'Gateway': '0.0.0.0',
  'Genmask': '255.255.255.0',
  'Iface': 'eth0',
  'Metric': '0',
  'Ref': '0',
  'Use': '0'}]
\end{lstlisting}
\paragraph{Funzionamento}
L'opreazione è classificata "sensibile" viene quindi creato un mongolog contenente le informazioni sull'operazione.
Viene poi controllato il tipo di parametro in ingresso, e se non è un dizionario viene generato un errore personalizzato
usando la funzione \nameref{commadn\string_error}.\\
La costruzione del comando avviene come si vede in codice, mixando le direttive alle informazioni contenute
nel dizionario in input. Infine viene lanciato il comando, verificato che non sono successe eccezioni e se tutto
è andato a buon fine viene chiamata la funzione di successo passandogli l'object id del documento mongo creato.
\paragraph{Return}
Restituisce il dizionario di successo senza dati (\texttt{data=None}) ma con l'object id del mongolog creato
alla chiave \texttt{logid}.

\subsection{Cron}
Il cron è un software incluso in tutte le distribuzioni Linux che copre il compito di eseguire
detereminati task (definiti dall'utente) con una certa frequenza e a specifici giorni e orari.\\
Un esempio di task ricorrente può essere ad esempio l'aggiornamento del database dei file per
la ricerca indicizzata.\\
Il cron di Linux può essere di sistema o dell'utente. Siccome usando il cron di sistema è possibile lanciare i processi
utilizzando qualsiasi utente del sistema si è deciso di tralasciare il cron utente ed implementare in nomodo
solo quello di sistema.\\
Distinguiamo 2 tipi di cron:
\begin{itemize}
	\item{Il cron utilizzato da \texttt{cronspath} e dagli script in \texttt{cron.d} che sono veri e propri
		script di cron, contenente cioè tutte le informazioni sulla tempistica di lancio del comando o
		dello script, l'utente e il comando stesso. Il comando in questo caso deve essere contenuto in una sola riga.
		In nomodo la creazione di tali script è possibile chiamando la funzione \nameref{addcron}}
	\item{Il cron delle cartelle \texttt{/etc/cron.daily}, \texttt{/etc/cron.hourly}, \texttt{/etc/cron.monthly} e \texttt{/etc/cron.weekly}
		che sono invece degli script o dei programmi (solitamente scrcitti in bash) che vengono eseguiti uno
		alla volta ordinati per nome all'ora e alla data definiti di default nel file \texttt{/ect/crontab}.
		In nomodo la creazione di tali script avviene tramite la chiamata alle funzioni derivate da \nameref{adddefaultcron},
		ad es. \texttt{adddailycron}}
\end{itemize}

\subsubsection{listcrontabs}
\begin{lstlisting}
def listcrontabs():

    basedir = '/etc/'
    paths = ['cron.d', 'cron.daily', 'cron.hourly', 'cron.monthly', 'cron.weekly']

    cronlist = dict()
    for path in paths:
        flist = os.listdir(basedir + path)
        flist.remove('.placeholder') 
        cronlist.update({ path: flist })

    return command_success( data=cronlist )
\end{lstlisting}
La funzione restituisce la lista di tutti i crontab installati nel sistema.
\paragraph{Parametri}
Non prende nessun parametro.
\paragraph{Funzionamento}
Definisce due variabili, \texttt{basedir} che è dove sono presenti le cartelle del cron e \texttt{paths} che è
una lista contenente i nomi delle cartelle del cron. Notare che la lista delle cartelle non contiene il file
\texttt{crontabs} che si è deciso di non utilizzare in quanto egregiamente sostituito dalla cartella \texttt{cron.d}.\\
Entrando nel ciclo for costruisce il dizionario \texttt{cronslist} la cui chiave è il nome della cartella mentre
il valore è la lista dei file presenti nella cartella stessa, che sarebbero quindi la lista dei crontab.
Da questa lista viene eliminato il file \texttt{.placeholder} che è solo un file richiesto dal sistema e non
utile all'utente finale.
\paragraph{Return}
Restitusice il dizionario di successo contenente nella variabile \texttt{data} il dizionario creato dalla funzione
come spiegato nel funzionamento. Un esempio del dizionario è il seguente:
\begin{lstlisting}
\end{lstlisting}

\subsubsection{getcroncontent}\label{getcroncontent}
\begin{lstlisting}
def getcroncontent(cronpath):

    try:
        with open(cronpath, 'r') as content:
            return command_success( data=content.read() )
    except FileNotFoundError:
        return command_error( returncode=10, stderr='No cron file found: "'+cronpath+'"' )
\end{lstlisting}
La funzione dato il path di un file di cron restituisce il contenuto dello stesso.
\paragraph{Parametri}
Accetta l'unico parametro \texttt{cronpath} che è il percorso del file di cron di cui leggerne il contenuto.
\paragraph{Funzionamento}
La funzione semplicemente apre il file in lettura utilizzando \texttt{with open()} e ne restituisce il contenuto.
Durante le sue operazioni controlla che non venga lanciata l'eccezione \texttt{FileNotFoundError} che avviene
quando il file che si sta cercando di aprire il lettura non esiste.
\paragraph{Return}
Restituisce il dizionario di successo contenente alla variabile \texttt{data} il contenuto del cron indicato.
Restituisce invece il dizionario di errore se viene generata l'eccezione \texttt{FileNotFoundError}, con
un codice di ritorno e un messaggio di errore personalizzato e che sono quello che si vedono in codice.

\subsubsection{getcronname}\label{getcronname}
\begin{lstlisting}
def getcronname(): return 'nomodo-' + datetime.datetime.now().strftime('%Y%m%d%H%M%S')
\end{lstlisting}
Genera un nome da usare per un nuovo cron. Viene usato principalmente in due fasi:
\begin{enumerate}
	\item{Viene chiamato dal frontend per riempire il campo \textit{name} all'aggiunta di un nuovo crontab.
		L'utente ovviamente ha la possibiltà di cammbiare questo nome prima dell'aggiunta dello script}
	\item{Chiamato dalle funzione di aggiunta cron \nameref{addcron} e \nameref{adddefaultcron} in quanto
		se il parametro \texttt{name} non è stato passato vanno ad utilizzare il nome restituito da
		questa funzione. Questa operazione sembra ridondante in quanto già chiamata dal frontend come
		spiegato al punto 1, ma serve a dare solidità al codice}
\end{enumerate}
\paragraph{Parametri}
Non prende nessun parametro.
\paragraph{Funzionamento}
Semplicemente contatena la stringa "nomodo-" alla data e ora odierna col formato che si vede nel codice.
\paragraph{Return}
È una delle pochissime funzione che non chiama una delle due funzioni di ritorno di nomodo.
Restituisce la stringa costruita come spiegato nel funzionamento.

\subsubsection{addcron}\label{addcron}
\begin{lstlisting}
def addcron( command, name="", user="root", minute='*', hour='*', dom='*', month='*', dow='*' ):

    cronspath = '/etc/cron.d/' 

    #New cron gets a random name if user did not provide it
    if not name: name = getcronname()

    logid = mongolog( locals() )

    with open(cronspath + name, 'w') as newcron:
        newcron.write( minute + ' ' + hour + ' ' + dom + ' ' + month + ' ' + dow + ' ' + user + ' ' + command + '\n' )

    return command_success( data=cronspath+name, logid=logid )
\end{lstlisting}
La funzione nsace per la creazione di uno script di cron vero che si vada ad aggiungere a quelli presenti nella cartella
\texttt{/etc/cron.d/}. Per "script di cron vero" si intende un file di direttive che contenga la sintassi del cron; come spiegato
nell'introduzione alla sezione \nameref{cron} questi si differenziano dagli script specifici in quanto questi ultimi sono
veri e propri applicativi, usualmente scritti in bash, mentre gli script di cron contengono anche le informazioni
sulla tempistica dell'esecuzione del comando e il comando deve essere contenuto in una linea o deve essere la chiamata
ad un applicativo.\\
La spiegazione di centos in questo esempio chiarisce ancora meglio come deve essere strutturato uno script di cron:ù
\begin{lstlisting}
# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed
\end{lstlisting}
Si intuisce da questo esempio che mentre i campi \texttt{dom} e \texttt{dow} interferiscano tra di loro. In realtà
settando entrambi il comando verrà eseguito sia nel "day of month" sia nel "day of week" specificari.
\paragraph{Parametri}
Accetta un sacco di parametri, qui spiegati:
\begin{itemize}
	\item{\texttt{command}: È il comando che deve essere eseguito. Deve essere di una sola riga e può essere sia
		un comando di bash che la chiamata ad un'applicativo di sistema, che può essere in qualsiasi linguaggio,
		incluso bash stesso (ovviamente)}
	\item{\texttt{name=""}: È il nome del nuovo script di bash. Se non specificato viene gererato automaticamente
		attraverso la chiamata alla funzione \nameref{getcronname}. In realtà la funzione viene chiamata
		direttamente dal frontend per settare il nome, ma per la massima sicurezza viene fatto un controllo
		per vedere se il nome è vuoto, e generarlo in tal caso}
	\item{\texttt{user="root"}: È l'utente per conto di cui il comando verrà lanciato. Di default è l'utenza amministrativa.}
	\item{\texttt{minute="*"}: È il minuto in cui il comando verrà eseguito. Di default è * che indica ogni minuto}
	\item{\texttt{hour="*"}: È l'ora in cui il comando verrà eseguito. Di default è * che indica ogni ora. Accetta valori
		da 0 a 24 ed è basato sul fuso orario del sistema}
	\item{\texttt{dom="*"}: È il giorno del mese (dom="day of month")  in cui il comando verrà eseguito.
		Di default è * che indica ogni giorno del mese. Accetta valori da 1 a 31 se il mese ha 31 giorni}
	\item{\texttt{month="*"}: È il mese in cui il comamndo deve essere eseguito. Di default è * che indica ogni mese.
		Accetta valori da 1 da 12}
	\item{\texttt{dow="*"}: È il giorno della settimana in cui il comando deve essere esguito.
		Di default è * che indica ogni gionro della settimana. Accetta valori da 1 a 7}
\end{itemize}
\paragraph{Funzionamento}
Una volta settato il path in cui il file verrà creato (\texttt{/etc/cron.d/}) si crea il mongolog in quanto bisogna tenere
traccia di chi ha creato il file, e semplicemente usando una \texttt{with open} si apre il file in scrittura e si scrivono
tutti le informazioni ricevute come parametri.
\paragraph{Return}
Restituisce il percorso del file creato e il logid del documento mongo contenente le informazioni sulla operazione nel dizionario
di successo generato dalla funzione \texttt{command\_success}.

\subsubsection{adddefaultcron}\label{adddefaultcron}
\begin{lstlisting}
def adddefaultcron(command, cronspath, name):

    #New cron gets a random name if user did not provide it
    if not name: name=getcronname()

    logid = mongolog( locals() )

    with open(cronspath + name, 'w') as newcron:
        newcron.write( command + '\n' )

    return command_success( data=cronspath+name, logid=logid )


def addhourlycron(command, name=""): return addefaultcron( name=name, command=command, cronspath='/etc/cron.hourly/' )
def adddailycron(command, name=""): return addefaultcron( command=command, cronspath='/etc/cron.daily/' )
def addweeklycron(command, name=""): return addefaultcron( command=command, cronspath='/etc/cron.weekly/' )
def addmonthlyycron(command, name=""): return addefaultcron( command=command, cronspath='/etc/cron.monthly/' )
\end{lstlisting}
La funzione si contrappone a \nameref{addcron} e a differenza di questo serve a creare uno script nelle cartelle
\texttt{/etc/cron.hourly}, \texttt{/etc/cron.daily}, \texttt{/etc/cron.weekly} e \texttt{cron.monthly}. Come spiegato
gli script di queste cartelle a differenza di quelli in \texttt{/etc/cron.d} sono veri e propri script
(solitamente script di bash) che vengono eseguiti ordinati per nome e secondo le direttive del file \texttt{/etc/crontab}.
Qui un esempio di tale file preso da un Ubuntu 16.04 server:
\begin{lstlisting}
# /etc/crontab: system-wide crontab
# Unlike any other crontab you don't have to run the `crontab'
# command to install the new version when you edit this file
# and files in /etc/cron.d. These files also have username fields,
# that none of the other crontabs do.

SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# m h dom mon dow user	command
17 *	* * *	root    cd / && run-parts --report /etc/cron.hourly
25 6	* * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6	* * 7	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6	1 * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
\end{lstlisting}
Quindi ad esempio tutti gli script in \texttt{/etc/cron.daily} verranno eseguiti ogni mattina alle ore 6:25.
\paragraph{Parametri}
Non prendendo informazioni ne sulla tempistica ne sull'utente prende pochi parametri, qui presentati:
\begin{itemize}
	\item{\texttt{command}: È il contenuto dello script che verrà aggiunto alle cartelle. In questo
		caso può essere multilinea. Il fontend può leggere questo contenuto ad esempio da una text area}
	\item{\texttt{cronspath}: Dato che questa funzione non andrebbe mami richiamata direttamente ma sempre
		attraverso le 4 funzioni che si vedono nelle ultime 4 righe del codice questo è un parametro
		che indica la cartella dove lo script sarà posizionato; questo cambia a seconda della funzione chiamata}
	\item{\texttt{name}: È il nome dello script di cron, che come per \nameref{addcron} se non presente viene
		generato tramite la chiamata alla funzione \nameref{getcronname}}
\end{itemize}
\paragraph{Funzionamento}
Come per \texttt{addcron} la funzione non fa altro che verificare che il nome sia presente e generarlo in caso negativo,
creare un documento mongo che memorizzi l'operazione effettuata e scrivere lo script (contenuto nella variabile \texttt{command})
nel nuovo file.\\
La funzione principale non va mai chiamata direttamente ma bisogna sempre utilizzare le 4 funzioni intermediare che si vedono
nelle ultime 4 righe del codice e che vanno a settare correttamente la variabile \texttt{cronspath} a seconda della tempistica
di esecuzione dello script.
\paragraph{Return}
Ugualemente a \texttt{addcron} restituisce il dizionario di successo contenete il percorso del nuovo file
nella variabile \texttt{data} e il l'object id del documento mongo contenente le informazioni sull'operazione
nella variabile \texttt{logid}.

\subsubsection{writecron}\label{writecron}
\begin{lstlisting}
def writecron( cronpath, newcontent ):
    return writefile( filepath=cronpath, newcontent=newcontent+'\n' )
\end{lstlisting}
Nasce per scrivere il contenuto di un file di cron. Ovviamente può essere usato per sovrascrivere completamente il contenuto
o in congiunzione con \nameref{getcroncontent} per aggiornarne il contenuto.
\paragraph{Parametri}
Prende 2 parametri:
\begin{itemize}
	\item{\texttt{cronpath}: È il percorso del file di cron che verrà scritto}
	\item{\texttt{newcontent}: È il nuovo contenuto del file che verrà scritto nel file indicato in \texttt{cronpath}}
\end{itemize}
\paragraph{Funzionamento}
La funzione è basata su \nameref{writefile} spiegata precedentemente.
\paragraph{Return}
Restituisce ciò che ritorna \nameref{writefile}.

\subsubsection{removecron}\label{removecron}
\begin{lstlisting}
def removecron(cronpath): delfile( path=cronpath )
\end{lstlisting}
Serve ad eliminare un file di cron e quindi a fermare l'esecuzione del comando in esso contenuto.
\paragraph{Parametri}
Accetta un solo parametro che è il percorso del file da eliminare.
\paragraph{Funzionamento}
La funzione è basata sulla funzione precedentemente spiegata \nameref{delfile}.
\paragraph{Return}
Restituisce ciò che ritora la funzione \nameref{delfile}.

\subsection{Sistema}\label{system}
Questa libreria è relativamente piccola per adesso ma sarà riempita con altre funzione in seguito. Contiene
tutte quelle funzione che riguardano il sistema in generale, come ad esempio la funzione per la visualizzione
e il cambio del nome macchina.

\subsubsection{hostname}\label{hostname}
\begin{lstlisting}
def hostname(newhostname=""):
    
    command = ['hostname']
        
    if newhostname:
        logid = mongolog( locals() )
        command.append(newhostname)

    try:
        hostname = check_output(command, stderr=PIPE, universal_newlines=True)
    except CalledProcessError as e:
        return command_error( e, command )

    if newhostname:
        return command_success( logid=logid )
    else:
        return command_success( data=hostname )
\end{lstlisting}
La funzione serve sia ad ottenere il nome macchina che a cambiarlo.
\paragraph{Parametri}
Accetta un solo parametro opzionale \texttt{newhostname} che contiene il nuovo nome macchina da assegnare alla stessa.
\paragraph{Funzionamento}
Il funzionamento è simile alla funzione hostname
\paragraph{Return}

\subsection{apache}\label{apache}
\subsection{Database}\label{database}
\subsection{File}\label{file}
\subsection{Logs}\label{logs}

\section{Frontend}\label{frontend}
Frontend
















\section{Utility}
\subsection{\href{https://developers.redhat.com/products/developertoolset/overview/}{Red Hat Developer Toolset}}

\subsection{Rimossi tra CentOS 6 e 7 e le cui alternative non presenti su CRESCO 6}
La seguente lista contiene i pacchetti che erano presenti su CRESCO 4 (Centos 6) e la cui alternativa per Centos 7 non è presente
nei sistemi di CRESCO 6, e che si dovrebbe quindi provvedere ad installare:
\begin{center}
	\renewcommand{\arraystretch}{1.5}
	\begin{tabular}{|l|l|}
		\hline
		\rowcolor{hgray}
		\textbf{Centos 6} & \textbf{Centos 7} \\
		\hline
		gtkhtml3 & webkitgtk3 \\ \hline
		libjpeg & libjpeg-turbo \\ \hline
		cpuspeed & kernel-tools \\ \hline
		nc & nmap-cnat \\ \hline
		procps & procps-ng \\ \hline
		openmotif22 & motif \\ \hline
		qpid,qm & Disponibile nella versione MRG di redhat \\ \hline
		pam\_passwdqc,pam\_cracklib & libpwquality, pam\_pwquality \\ \hline
		hal* & udev \\ \hline
		axis & java-1.7.0-openjdk \\ \hline
		classpath[x]?-jaf & java-1.7.0-openjdk \\ \hline
		classpath[x]?-mail & javamail \\ \hline
		db4-cxxi & libdb4-cxx \\ \hline
		db4-utils & libdb4-utils \\ \hline
		eggdbus & glib2 \\ \hline
		gcc-java & java-1.7.0-openjdk-devel \\ \hline
		GConf2-gtk & GConf2 \\ \hline
		geronimo-specs & geronimo-parent-poms \\ \hline
		geronimo-specs-compat & geronimo-jms, geronimo-jta \\ \hline
		hal-devel & systemd-devel \\ \hline
		ibus-gtk & ibus-gtk2 \\ \hline
		jakarta-commons-net & apache-commons-net \\ \hline
		junit4 & junit \\ \hline
		m17n-contrib-* & m17n-contrib \\ \hline
		m17n-db-* & m17n-db,m17n-db-extras \\ \hline
		seekwatcher & iowatcher \\ \hline
		udisks & udisks2 \\ \hline
		unique & unique2,glib2 \\ \hline
		unix2dos & dos2unix \\ \hline
	\end{tabular}
\end{center}

\subsection{Rimossi da Centos 6 e 7 e le cui alternative sono presenti su CRESCO 6}
La seguente lista contiene i pacchetti che erano presenti su CRESCO 4 (Centos 6) e la cui alternativa per Centos 7 è presente
nei sistemi di CRESCO 6, e che quindi non è necessario installare:
\begin{center}
	\renewcommand{\arraystretch}{1.5}
	\begin{tabular}{|l|l|}
		\hline
		\rowcolor{hgray}
		\textbf{Centos 6} & \textbf{Centos 7} \\
		\hline
		vconfig & iproute \\ \hline
		module-init-tools & kmod \\ \hline
		man & man-db \\ \hline
		ecrypt & Integrato nei tool esistenti \\ \hline
		perl-suidperl & perl \\ \hline
		ConsoleKit* & systemd \\ \hline
		busybox & Utility integrate \\ \hline
		dracut-kernel & dracut \\ \hline
		hal & systemd \\ \hline
		mingetty & util-linux \\ \hline
		nss\_db & glibc \\ \hline
		polkit-desktop-policy & polkit \\ \hline
		qt-sqlite & qt \\ \hline
	\end{tabular}
\end{center}

\end{document}
