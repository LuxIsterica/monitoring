\documentclass[11pt]{article}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage[margin=0.9in]{geometry}
\usepackage{color, colortbl}

\definecolor{hgray}{gray}{0.9}
 
\pagestyle{fancy}
\def\sectionautorefname{Section}


\title{nomodo - Manage your system by yourself}
\author{Autori (in ordine alfabetico): \and Giuseppe Glorioso \and Lucia Polizzi}

\begin{document}
\lstset{
	language=Python,
	frame=single,
	breaklines=true,
	breakatwhitespace=false,
	backgroundcolor=\color{hgray}
}
\maketitle
\pagenumbering{gobble}

\newpage
\tableofcontents
\pagenumbering{arabic}

\newpage

\section{Introduzione}

\subsection{Introduzione al progetto}
Il progetto nomodo nasce dalla necessit\'a di un applicativo di gestione dei sistemi Ubuntu che sia più immediato ed accessibile
rispetto al classico terminale, e quindi utilizzabile anche dagli utenti che per un motivo o per un altro
non possono o non vogliono avere a che fare con il terminale.
Nomodo si prende in carico di eseguire tutte le chiamate al terminale o meno per eseguire operazioni atte alla gestione del sistema
presentando all'utente una interfaccia web chiara e comprensibile.
Per operazioni in questo caso si intendono l'aggiornamento, la manutenzione e il miglioramento del sistema come ad esempio
l'installazione dei pacchetti, la ricerca e la modifica dei file, così come operazioni di più alto livello come
la gestione basilare del web server Apache.

\subsection{Informazioni tecniche}
\paragraph{Python + Flask}
L'applicativo scritto in python è basato sul framework Flask, utilizzato tra l'altro come webserver per l'accesso al pannello.
Durante la fase di sviluppo si è utilizzato nginx come reverse proxy in modo da poter raggiungere il pannello web sulla porta 80 e non sulla 5000.
È stata presa poi in seguito la decisione di lasciare che l'applicativo girasse sulla porta 5000 in quannto meno comune e quindi
meno alla mercé degli hacker.
\\~\\
L'applicazione è stata quindi divisa in modo netto nelle due componenti fondamentali, il \nameref{frontend} e il \nameref{backend}
che anche andremo quindi ad analizzare qui brevemente e più approfinditamente nei capitoli successivi:
\begin{itemize}
	\label{backendintro}
	\item{
			Il \textbf{backend} consiste in una serie di funzioni raccolte in una serie di file a mò di libreria,
			risiedenti nella cartella \texttt{systemcalls} (come ad es. \texttt{system.py} o \texttt{user.py}), utilizzati
			sia per la raccolta di dati sia per eseguire azioni sul sistema che non necessitano di output in uscita}
	\label{frontendintro}
	\item{
			Il \textbf{frontend} rappresenta la parte grafica dell'applicativo web, e utilizza le funzioni
			del backend per la ricerca di informazioni e per la modifica alle componenti del sistema
			inclusa la modifica dei file quali i file di configurazioni}
\end{itemize}

\paragraph{MongoDB}
Ogni operazione sensibile effettuata tramite l'applicazione comporta la memorizzazione delle modifiche che comporta la stessa
in documento di mongodb, cos\'i da poter risalire alla storia delle operazioni effettuate e tentare un revert delle modifiche
in caso ad esempio il sistema perda di stabilità o le modifiche non portino al risultato sperato.
Tali operazioni possono riguardare ad esempio la modifica di un file, o la rimozione di un pacchetto dal sistema.
Ogni log in mongodb presenta inoltre un flag \textbf{status} che indica se l'operazione eseguita sia andata a buon fine
o meno, in modo da rendere più chiara la navigazione tra i log e dare la possibiltà all'utente di filtrarli in base a questo campo.
\footnote{\label{loglimit1}
Le uniche operazioni memorizzate nel database sono quelle relative all'utilizzo dell'applicativo;
una modifica effettuata direttamente sul sistema ad esempio tramite il terminale va incontro alle regole del sistema Ubuntu
e ogni modifica potrebbe essere irreversibile. In questi casi fare riferimento ai log del sistema che è possibile trovare
al percorso \texttt{/var/log/} o sul pannello web alla sezione \texttt{Log}. }

\section{Backend}\label{backend}
Come anticipato in sezione \ref{backendintro} il backend è composto da una serie di funzioni raggruppate per categoria
che fanno utilizzo di varie librerie python per compiere operazioni che possono o meno alterare lo stato del sistema.
Allo stato attuale le categorie che compongono il backend sono le seguenti:
\begin{itemize}
	\item{Utenti}
	\item{Network}
	\item{Cron}
	\item{Sistema}
	\item{Apache}
	\item{Database}
	\item{File}
	\item{Logs}
\end{itemize}

\paragraph{Interfaccia al frontend}\label{frontendinterface}
Ogni funzione chimata restituisce sempre un dizionario contenente un codice di ritorno e a seconda dei casi
i dati che si sono richiesti se il codice di ritorno è 0 o una variabile \texttt{stderr} contenente un messaggio di errore
se il codice di ritorno è diverso da 0.
Il frontend o l'utente che voglia chiamare per qualsivoglia motivo le funzioni del backend direttamente, potr\'a farlo quindi nel seguente modo::
\begin{lstlisting}
data = getifacestat()
if data['returncode'] is 0:
	data = data['data']
else:
	print( data['stderr'] )
 
pprint(data)
\end{lstlisting}

\paragraph{subprocess}\label{subprocess}
Le funzionalità di Python più utilizzate per la realizzazione del progetto sono senza dubbio quelle appartenenti alla libreria subprocess,
che permette di eseguire comandi come se si stessero eseguendo in bash. Si è cercato il più possibile di limitare l'utilizzo di questa libreria
ma le sue funzionalità si sono rese necessarie nella maggior parte dei casi delle funzioni del backend,
a causa dello scarsa agilità che ha python di interfacciarsi col sistema sottostante.
In generale l'esecuzione di un comando avviene nel seguente modo:
\begin{lstlisting}
command = ['ifconfig', '-a']
try:
	output = check_output(command, stderr=PIPE, universal_newlines=True)
except CalledProcessError as e:
	return command_error(e, command, logid)

return command_success( output )
\end{lstlisting}
Se viene lanciata l'eccezione \texttt{CalledProcessError} allora chiama la funzione \texttt{ \nameref{command\string_error} }
che restituisce quindi un dizionario contenente un \texttt{returncode} diverso da 0 (quindi errore)
e un messaggio di errore che si trova nella chiave \texttt{stderr} oltre al logid dell'operazione se applicabile e al comando lanciato
per causare l'errore. \\
In questo specifico caso invece se l'operazione va buon fine viene invocata la funzione \texttt{ \nameref{command\string_success} }
che restituisce un \texttt{returncode} uguale a 0, e l'output sulla shell nella chiave di dizionario  \texttt{data} e \texttt{logid}
se applicabile. \\
In caso invece il comando che si va ad eseguire non restituisce output la chiave \texttt{data} sarà nulla mentre se l'operazione è una
operazione sensibile sarà restituito il \texttt{logid} di mongo.
Un esempio di quest'ultimo caso è rappresentato dalla funzione \textit{removeuser}:
\begin{lstlisting}
def removeuser(user, removehome=None):
        
    logid = mongolog( locals(), getuser(user) )
    

    try:
        command = ['deluser', user]
        if removehome: command.append('--remove-home') 

        check_output( command, stderr=PIPE, universal_newlines=True )
    except CalledProcessError as e:
        return command_error(e, command, logid)
    
    
    return command_success(logid)
\end{lstlisting}
Nelle prossime sezioni verranno analizzate tutte le categorie e spiegato il funzionamento di ogni funzione che contengono.

\subsection{utilities}
Questa categoria contiene per la maggior parte funzioni che non vengono mai richiamate direttamente dal frontend, ma vengono utilizzate
dalle altre funzioni del backend. Fa eccezione invece la funzione \nameref{filedit} utile alla modifica di file. \\
Analizziamo adesso le funzioni di questa libreria.
\subsubsection{mongolog()}\label{mongolog}
\begin{lstlisting}
def mongolog(params, *args):

    dblog = dict({
    	'date': datetime.datetime.utcnow(),     #Operation date
    	'funname': inspect.stack()[1][3],       #Function name
    	'parameters': params,			#Called function's parameters
    })
    
    for arg in args:
        dblog.update( arg )

    #ObjectID in mongodb
    return db.log.insert_one( dblog ).inserted_id
\end{lstlisting}
Viene chiamata da ogni funzione che va a modificare lievemente o pesantemente il sistema e fa un insert su mongodb per memorizzare le informazioni.
Accetta N parametri di cui \textbf{il primo} (che deve essere sempre presente) è la lista di parametri
con cui è stata lanciata la funzione che ha chiamato \texttt{mongolog}. Ad esempio in
\begin{lstlisting}
def ifacedown( iface ):
	logid = mongolog( locals() )
	...
\end{lstlisting}
a \texttt{mongolog} viene passata \texttt{locals()} che contiene il parametro \texttt{iface} e che andrà quindi an inserire nel dizionario
di base che restituir\'a, mentre \textbf{il secondo} parametro è opzionale e può essere uno o più dizionari da unire a questo dizionario restituito.
\\~\\
Il dizionario di base è formato da tre elementi:
\begin{itemize}
	\item{La data in cui viene effettuata l'operazione}
	\item{Il nome della funzione che ha chiamato \texttt{mongolog}, ricavata tramite il supporto della libreria \texttt{inspect}}
	\item{I parametri della funzione che chiama, come spiegato in precedenza, e ottenuti chiamando la funzione \texttt{locals()}}
\end{itemize}

\subsubsection{changemongologstatus() e funzioni collegate }\label{logstatus}
\begin{lstlisting}
def changemongologstatus(logid):

    return db.log.update_one(
        {'_id': logid},
        {'$set': { 'status' : 'error' }},
        upsert=False
        )

def mongologstatuserr(logid, status='error'):
    return changemongologstatus(logid, status)
def mongologstatussuc(logid, status='success')                                                              #
    return changemongologstatus(logid, status) #riprenderedaqui
\end{lstlisting}
Questa funzione è intesa per modificare il campo \texttt{status} di un documento di MongoDB. Le funzioni di nomodo (come è giusto che sia)
creano un documento di mongo per memorizzare le informazioni sull'operazione prima di procedere all'operazione stessa.
In caso un'operazione non andasse nel modo aspettato quindi bisognerebbe marcare il documento appena creato in mongo in modo da avvisare l'utente
che sta consultando il log che l'operazione riferita a quel documento non è andata a buon fine; è proprio qui che interviene il campo \texttt{status}.
Alla creazione del documento questo campo è \texttt{success} per poi essere modificato a seconda di come è andata l'operazione


\subsubsection{mongologstatuserr}\label{mongologstatuserr}

\subsubsection{command\_success}\label{command\string_success}
\begin{lstlisting}
def command_success( data=None, returncode=0 ):
    return dict({
        'returncode': returncode,
        'data': data
    })
\end{lstlisting}
La funzione \texttt{command\_success} viene chiamata ogni qualvolta una funzione del backend inclusa nelle altre categorie esegue l'operazione
richiesto in modo corretto ed è quindi in grado di informare l'utente del successo dell'operazione.
Questa funzione (cos\'i come \texttt{command\_error}) viene chiamata da quasi tutte le funzioni al return; fanno eccezione le funzioni che
per un motivo o per un altro non possono utilizzarla. In tal caso queste andranno a generare un dizionario proprio da restituire al frontend
che avr\'a per\'o la stessa struttura del dizionario restituito da questa funzione.
\\~\\
\paragraph{Parametri}
Accetta due parametri:
\begin{itemize}
	\item{Il primo che è \texttt{data} contiene i dati effettivi da restituire all'utente. Come gi\'a detto se l'operazione genera output
		allora conterr\'a questo output, altrimenti il logid di mongodb e infine se proprio non c'è niente da restituire verr\'a
		una variabile vuota}
	\item{Il secondo che non è obbligatorio, è il returncode. Di base questa funzione dovrebbe restituire sempre 0 ma è stata data
		la possibilit\'a di inserire returncode diversi da 0 per implementazioni (improbabili) future.}
\end{itemize}
\paragraph{Costruisce il dizionario da restituire}
\paragraph{Return}
Restituisce un dizionario contenente un \texttt{returncode} e una variabile \texttt{data} che assume il tipo dei dati da restituire,
da utilizzare come spiegato in sezione \ref{frontendinterface}.

\subsubsection{command\_error}\label{command\string_error}
\begin{lstlisting}
def command_error(e, c):

    return dict({
        'returncode': e.returncode,
        'command': ' '.join(c),
        'stderr': e.stderr
    })
\end{lstlisting}
\texttt{command\_error} è l'opposto di \texttt{command\_success}. Come visto in sezione \ref{subprocess} viene invocato quando
un comando lanciato attraverso la libreria \texttt{subprocess} fallisce nell'esecuzione.
\paragraph{Parametri}
Accetta 2 parametri di cui:
\begin{itemize}
	\item{Il primo è l'oggetto creato al lancio dell'eccezione \texttt{CalledProcessError}}
	\item{Il secondo è il comando che è andato in errore}
\end{itemize}
\paragraph{Funzionamento}
Costruisce il dizionario da restituire inserendovi il \texttt{returncode} dell'eccezione lanciata, il comando che ha causato l'eccezione
unito in una sola stringa usando il comando \texttt{join} e il messaggio di errore così come restituito dall'eccezione
\paragraph{Return}
Restituisce il dizionario creato come descritto nel funzionamento.

\subsubsection{filedit}\label{filedit}
\subsubsection{filediff}\label{filediff}

\subsection{Utenti}
\subsection{Network}
\subsection{Cron}
\subsection{Sistema}
\subsection{apache}
\subsection{Database}
\subsection{File}
\subsection{Logs}

\section{Frontend}\label{frontend}
Frontend

\section{Utility}
\subsection{\href{https://developers.redhat.com/products/developertoolset/overview/}{Red Hat Developer Toolset}}

\subsection{kerberos5}
\begin{enumerate}
	\item{Copiare il file \texttt{/etc/krb5.conf} da uno dei nodi di cresco 4}
	\item{Abilitare kerberos come tipologia di autenticazione:\newline\texttt{authconfig --enablekrb5 --updateall}}
	\item{Utilizzare klog.krb5 come klog di default:}
		\begin{itemize}
			\item{\texttt{mv /usr/bin/klog /usr/bin/klog.orig}}
			\item{\texttt{ln -s /usr/bin/klog.krb5 /usr/bin/klog}}
		\end{itemize}
	\item{Copiare il keytab da cresco-inst1:\newline\texttt{cp /afs/enea.it/system/arc/keytab/services/host/cresco4x002.portici.enea.it /etc/krb5.keytab}}
	\item{Link simbolici alle shell? Discuterne con Guido}
	\item{Creare un link simbolico per pagsh:\newline\texttt{ln -s /usr/bin/pagsh /usr/afsws/bin/pagsh}}
\end{enumerate}

\subsection{Rimossi tra CentOS 6 e 7 e le cui alternative non presenti su CRESCO 6}
La seguente lista contiene i pacchetti che erano presenti su CRESCO 4 (Centos 6) e la cui alternativa per Centos 7 non è presente
nei sistemi di CRESCO 6, e che si dovrebbe quindi provvedere ad installare:
\begin{center}
	\renewcommand{\arraystretch}{1.5}
	\begin{tabular}{|l|l|}
		\hline
		\rowcolor{hgray}
		\textbf{Centos 6} & \textbf{Centos 7} \\
		\hline
		gtkhtml3 & webkitgtk3 \\ \hline
		libjpeg & libjpeg-turbo \\ \hline
		cpuspeed & kernel-tools \\ \hline
		nc & nmap-cnat \\ \hline
		procps & procps-ng \\ \hline
		openmotif22 & motif \\ \hline
		qpid,qm & Disponibile nella versione MRG di redhat \\ \hline
		pam\_passwdqc,pam\_cracklib & libpwquality, pam\_pwquality \\ \hline
		hal* & udev \\ \hline
		axis & java-1.7.0-openjdk \\ \hline
		classpath[x]?-jaf & java-1.7.0-openjdk \\ \hline
		classpath[x]?-mail & javamail \\ \hline
		db4-cxxi & libdb4-cxx \\ \hline
		db4-utils & libdb4-utils \\ \hline
		eggdbus & glib2 \\ \hline
		gcc-java & java-1.7.0-openjdk-devel \\ \hline
		GConf2-gtk & GConf2 \\ \hline
		geronimo-specs & geronimo-parent-poms \\ \hline
		geronimo-specs-compat & geronimo-jms, geronimo-jta \\ \hline
		hal-devel & systemd-devel \\ \hline
		ibus-gtk & ibus-gtk2 \\ \hline
		jakarta-commons-net & apache-commons-net \\ \hline
		junit4 & junit \\ \hline
		m17n-contrib-* & m17n-contrib \\ \hline
		m17n-db-* & m17n-db,m17n-db-extras \\ \hline
		seekwatcher & iowatcher \\ \hline
		udisks & udisks2 \\ \hline
		unique & unique2,glib2 \\ \hline
		unix2dos & dos2unix \\ \hline
	\end{tabular}
\end{center}

\subsection{Rimossi da Centos 6 e 7 e le cui alternative sono presenti su CRESCO 6}
La seguente lista contiene i pacchetti che erano presenti su CRESCO 4 (Centos 6) e la cui alternativa per Centos 7 è presente
nei sistemi di CRESCO 6, e che quindi non è necessario installare:
\begin{center}
	\renewcommand{\arraystretch}{1.5}
	\begin{tabular}{|l|l|}
		\hline
		\rowcolor{hgray}
		\textbf{Centos 6} & \textbf{Centos 7} \\
		\hline
		vconfig & iproute \\ \hline
		module-init-tools & kmod \\ \hline
		man & man-db \\ \hline
		ecrypt & Integrato nei tool esistenti \\ \hline
		perl-suidperl & perl \\ \hline
		ConsoleKit* & systemd \\ \hline
		busybox & Utility integrate \\ \hline
		dracut-kernel & dracut \\ \hline
		hal & systemd \\ \hline
		mingetty & util-linux \\ \hline
		nss\_db & glibc \\ \hline
		polkit-desktop-policy & polkit \\ \hline
		qt-sqlite & qt \\ \hline
	\end{tabular}
\end{center}

\end{document}
