\documentclass[11pt]{article}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage[margin=0.9in]{geometry}
\usepackage{color, colortbl}

\definecolor{hgray}{gray}{0.9}
 
\pagestyle{fancy}
\def\sectionautorefname{Section}


\title{nomodo - Manage your system by yourself}
\author{Autori (in ordine alfabetico): \and Giuseppe Glorioso \and Lucia Polizzi}

\begin{document}
\lstset{
	language=Python,
	frame=single,
	breaklines=true,
	breakatwhitespace=false,
	backgroundcolor=\color{hgray}
}
\maketitle
\pagenumbering{gobble}

\newpage
\tableofcontents
\pagenumbering{arabic}

\newpage

\section{Introduzione}

\subsection{Introduzione al progetto}
Il progetto nomodo nasce dalla necessit\'a di un applicativo di gestione dei sistemi Ubuntu che sia più immediato ed accessibile
rispetto al classico terminale, e quindi utilizzabile anche dagli utenti che per un motivo o per un altro
non possono o non vogliono avere a che fare con il terminale.
Nomodo si prende in carico di eseguire tutte le chiamate al terminale o meno per eseguire operazioni atte alla gestione del sistema
presentando all'utente una interfaccia web chiara e comprensibile.
Per operazioni in questo caso si intendono l'aggiornamento, la manutenzione e il miglioramento del sistema come ad esempio
l'installazione dei pacchetti, la ricerca e la modifica dei file, così come operazioni di più alto livello come
la gestione basilare del web server Apache.

\subsection{Informazioni tecniche}
\paragraph{Python + Flask}
L'applicativo scritto in python è basato sul framework Flask, utilizzato tra l'altro come webserver per l'accesso al pannello.
Durante la fase di sviluppo si è utilizzato nginx come reverse proxy in modo da poter raggiungere il pannello web sulla porta 80 e non sulla 5000.
È stata presa poi in seguito la decisione di lasciare che l'applicativo girasse sulla porta 5000 in quannto meno comune e quindi
meno alla mercé degli hacker.
\\~\\
L'applicazione è stata quindi divisa in modo netto nelle due componenti fondamentali, il \nameref{frontend} e il \nameref{backend}
che anche andremo quindi ad analizzare qui brevemente e più approfinditamente nei capitoli successivi:
\begin{itemize}
	\label{backendintro}
	\item{
			Il \textbf{backend} consiste in una serie di funzioni raccolte in una serie di file a mò di libreria,
			risiedenti nella cartella \texttt{systemcalls} (come ad es. \texttt{system.py} o \texttt{user.py}), utilizzati
			sia per la raccolta di dati sia per eseguire azioni sul sistema che non necessitano di output in uscita}
	\label{frontendintro}
	\item{
			Il \textbf{frontend} rappresenta la parte grafica dell'applicativo web, e utilizza le funzioni
			del backend per la ricerca di informazioni e per la modifica alle componenti del sistema
			inclusa la modifica dei file quali i file di configurazioni}
\end{itemize}

\paragraph{MongoDB}
Ogni operazione sensibile effettuata tramite l'applicazione comporta la memorizzazione delle modifiche che comporta la stessa
in documento di mongodb, cos\'i da poter risalire alla storia delle operazioni effettuate e tentare un revert delle modifiche
in caso as esempio il sistema perda di stabilità o le modifiche non portino al risultato sperato.
Tali operazioni possono riguardare ad esempio la modifica di un file, o la rimozione di un pacchetto dal sistema.
\footnote{\label{loglimit1}
Le uniche operazioni memorizzate nel database sono quelle relative all'utilizzo dell'applicativo;
una modifica effettuata direttamente sul sistema ad esempio tramite il terminale va incontro alle regole del sistema Ubuntu
e ogni modifica potrebbe essere irreversibile. In questi casi fare riferimento ai log del sistema che è possibile trovare
al percorso \texttt{/var/log/} o sul pannello web alla sezione \texttt{Log}. }

\section{Backend}\label{backend}
Come anticipato in sezione \ref{backendintro} il backend è composto da una serie di funzioni raggruppate per categoria
che fanno utilizzo di varie librerie python per compiere operazioni che possono o meno alterare lo stato del sistema.
Allo stato attuale le categorie che compongono il backend sono le seguenti:
\begin{itemize}
	\item{Utenti}
	\item{Network}
	\item{Cron}
	\item{Sistema}
	\item{Apache}
	\item{Database}
	\item{File}
	\item{Logs}
\end{itemize}

\paragraph{Interfaccia al frontend}
Il messaggio di errore nella maggior parte dei casi è lo stesso messaggio restituito all'utente sulla shell,
ma inserito nella variabile \texttt{stderr}.

\paragraph{subprocess}
Le funzionalità di Python più utilizzate per la realizzazione del progetto sono senza dubbio quelle appartenenti alla libreria subprocess,
che permette di eseguire comandi come se si stessero eseguendo in bash. Si è cercato il più possibile di limitare l'utilizzo di questa libreria
ma le sue funzionalità funzionalità state necessarie nella maggior parte delle funzioni del backend, a causa dello scarso agilità che ha python
di interfacciarsi col sistema sottostante.
In generale l'esecuzione di un comando avviene nel seguente modo:
\begin{lstlisting}
command = ['ifconfig', '-a']
try:
	output = check_output(command, stderr=PIPE, universal_newlines=True)
except CalledProcessError as e:
	return command_error(e, command)

return command_success( output )
\end{lstlisting}
Se viene lanciata l'eccezione \texttt{CalledProcessError} allora chiama la funzione \nameref{\texttt{command\_error}} che restituisce quindi
contenente un \texttt{returncode} diverso da 0 (quindi errore) e un messaggio di errore che si trova nella chiave \texttt{stderr}.
In questo specifico caso invece se l'operazione va buon fine viene invocata la funzione \nameref{\texttt{command\_success}} che restituisce
un \texttt{returncode} uguale a 0 e l'output sulla shell del comando eseguito nella chiave di dizionario \texttt{data}.
In caso invece il comando che si va ad eseguire non restituisce output, la chiave \texttt{data} andrà a contenere il \texttt{logid}
di mongo, che non è altro l'Object ID del documento che è stato creato in mongo e contenente le informazioni sull'operazione appena effettuata.
Un esempio è l'esecuzione del seguente codice:
\begin{lstlisting}
def removeuser(user, removehome=None):
        
    logid = mongolog( locals(), getuser(user) )
    

    try:
        command = ['deluser', user]
        if removehome: command.append('--remove-home') 

        check_output( command, stderr=PIPE, universal_newlines=True )
    except CalledProcessError as e:
        return command_error(e, command)
    
    
    return command_success(logid)
\end{lstlisting}

Nei prossimi sezioni verranno analizzate tutte le categorie e spiegato il funzionamento di ogni funzione che contengono.
\subsection{utilities}
\subsubsection{command\_success}\label{command\_success}
\subsubsection{command\_error}\label{command\_error}
\subsection{Utenti}
\subsection{Network}
\subsection{Cron}
\subsection{Sistema}
\subsection{apache}
\subsection{Database}
\subsection{File}
\subsection{Logs}

\section{Frontend}\label{frontend}
Frontend\label{

\section{Utility}
\subsection{\href{https://developers.redhat.com/products/developertoolset/overview/}{Red Hat Developer Toolset}}
\begin{itemize}
	\item{systemtap-devel}
	\item{systemtap-client}
	\item{systemtap}
	\item{systemtap-runtime}
	\item{oprofile}
\end{itemize}

\paragraph{Limiti utenti}
Appendere al file \texttt{/etc/security/limits.conf} le seguenti direttive\footnote{\label{limitsnotneededyet}Le direttive su memlock unlimited sono state omesse in quanto già presenti}:
\begin{lstlisting}
#ENEA custom
* soft stack 2097152
* hard stack 2097152
* soft fsize 524288000
* hard fsize 524288000
* soft nofile 8192
* hard nofile 8192
\end{lstlisting}

\subsection{OpenAFS}
\begin{itemize}
	\item{Installare i pacchetti di openafs che si trovano sulla macchina \texttt{cresco-inst1} al percorso \texttt{/root/AFS}}
	\item{Copiare tutti i file a livello 0 di \texttt{/usr/vice/etc/} di inst1 nello stesso percorso sulla macchina locale}
	\item{Giovanni Bracco: Continuare}
\end{itemize}

\subsection{kerberos5}
\begin{enumerate}
	\item{Copiare il file \texttt{/etc/krb5.conf} da uno dei nodi di cresco 4}
	\item{Abilitare kerberos come tipologia di autenticazione:\newline\texttt{authconfig --enablekrb5 --updateall}}
	\item{Utilizzare klog.krb5 come klog di default:}
		\begin{itemize}
			\item{\texttt{mv /usr/bin/klog /usr/bin/klog.orig}}
			\item{\texttt{ln -s /usr/bin/klog.krb5 /usr/bin/klog}}
		\end{itemize}
	\item{Copiare il keytab da cresco-inst1:\newline\texttt{cp /afs/enea.it/system/arc/keytab/services/host/cresco4x002.portici.enea.it /etc/krb5.keytab}}
	\item{Link simbolici alle shell? Discuterne con Guido}
	\item{Creare un link simbolico per pagsh:\newline\texttt{ln -s /usr/bin/pagsh /usr/afsws/bin/pagsh}}
\end{enumerate}

\subsection{Rimossi tra CentOS 6 e 7 e le cui alternative non presenti su CRESCO 6}
La seguente lista contiene i pacchetti che erano presenti su CRESCO 4 (Centos 6) e la cui alternativa per Centos 7 non è presente
nei sistemi di CRESCO 6, e che si dovrebbe quindi provvedere ad installare:
\begin{center}
	\renewcommand{\arraystretch}{1.5}
	\begin{tabular}{|l|l|}
		\hline
		\rowcolor{hgray}
		\textbf{Centos 6} & \textbf{Centos 7} \\
		\hline
		gtkhtml3 & webkitgtk3 \\ \hline
		libjpeg & libjpeg-turbo \\ \hline
		cpuspeed & kernel-tools \\ \hline
		nc & nmap-cnat \\ \hline
		procps & procps-ng \\ \hline
		openmotif22 & motif \\ \hline
		qpid,qm & Disponibile nella versione MRG di redhat \\ \hline
		pam\_passwdqc,pam\_cracklib & libpwquality, pam\_pwquality \\ \hline
		hal* & udev \\ \hline
		axis & java-1.7.0-openjdk \\ \hline
		classpath[x]?-jaf & java-1.7.0-openjdk \\ \hline
		classpath[x]?-mail & javamail \\ \hline
		db4-cxxi & libdb4-cxx \\ \hline
		db4-utils & libdb4-utils \\ \hline
		eggdbus & glib2 \\ \hline
		gcc-java & java-1.7.0-openjdk-devel \\ \hline
		GConf2-gtk & GConf2 \\ \hline
		geronimo-specs & geronimo-parent-poms \\ \hline
		geronimo-specs-compat & geronimo-jms, geronimo-jta \\ \hline
		hal-devel & systemd-devel \\ \hline
		ibus-gtk & ibus-gtk2 \\ \hline
		jakarta-commons-net & apache-commons-net \\ \hline
		junit4 & junit \\ \hline
		m17n-contrib-* & m17n-contrib \\ \hline
		m17n-db-* & m17n-db,m17n-db-extras \\ \hline
		seekwatcher & iowatcher \\ \hline
		udisks & udisks2 \\ \hline
		unique & unique2,glib2 \\ \hline
		unix2dos & dos2unix \\ \hline
	\end{tabular}
\end{center}

\subsection{Rimossi da Centos 6 e 7 e le cui alternative sono presenti su CRESCO 6}
La seguente lista contiene i pacchetti che erano presenti su CRESCO 4 (Centos 6) e la cui alternativa per Centos 7 è presente
nei sistemi di CRESCO 6, e che quindi non è necessario installare:
\begin{center}
	\renewcommand{\arraystretch}{1.5}
	\begin{tabular}{|l|l|}
		\hline
		\rowcolor{hgray}
		\textbf{Centos 6} & \textbf{Centos 7} \\
		\hline
		vconfig & iproute \\ \hline
		module-init-tools & kmod \\ \hline
		man & man-db \\ \hline
		ecrypt & Integrato nei tool esistenti \\ \hline
		perl-suidperl & perl \\ \hline
		ConsoleKit* & systemd \\ \hline
		busybox & Utility integrate \\ \hline
		dracut-kernel & dracut \\ \hline
		hal & systemd \\ \hline
		mingetty & util-linux \\ \hline
		nss\_db & glibc \\ \hline
		polkit-desktop-policy & polkit \\ \hline
		qt-sqlite & qt \\ \hline
	\end{tabular}
\end{center}

\end{document}
